!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! 09/25/2022
! ADD SINUSOIDAL SPIN PINNING FIELDS; USING PERIODIC BOUNDARY CONDITION (PBC)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! PROGRAM: Several subroutines used to construct the kinetic propagator Exp(-/+dt*H_0) and Exp(-/+dt*H_0/2) for CPMC 
!                   simulations.
! COMMENT: Exp(-/+dt*H_0) and Exp(-/+dt*H_0/2).
! AUTHOR:  Yuan-Yao He
! DATE:    2020-02-27
! PURPOSE: Different subroutines are introduced as following:
!
!          In this code, we write the many-body Hamiltonian H as H = H_0 + H_I = H_T + (H_I + H_0 - H_T).
!             
!   InitExpHmltK  --> Subroutine used to calculate the kinetic propagators Exp(-/+dt*H_0) and Exp(-/+dt*H_0/2);
!
!   ExpH0kEgVlFFT --> Subroutine used to calculate Exp(-/+dt*H_0) and Exp(-/+dt*H_0/2) by FFT;
!
!   ExpH0kFullMat --> Subroutine used to calculate Exp(-/+dt*H_0) and Exp(-/+dt*H_0/2) by matrix multiplication;
!   GenerateH0Mat --> Subroutine used to construct the r-space matrix of H_0.
!             
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
   

!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
   subroutine InitExpHmltK()
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  InitExpHmltK()
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to calculate full/half of exponential kinect matrices, for both B_T and B_X.
! KEYWORDS: Exponential kinetic matrices.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION: Both \exp(\pm\Delta\tau*K) and \exp(\pm\Delta\tau*K/2) are obtained, for both B_T and B_X matrices.
!
!     This just calculate the eigenvalues of the H_T without \mu_T chemical potential term, but the eigenvectors 
!            are exactly the same. 
!
!     Input:  (none)   Output: (none)
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________     
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
      use RealPrecsn
      use CoreParamt
      use MPISetting
      implicit none
!______________________________________________________________________________________________________________     
!___________________________ Main calculations of exponential hopping matrices ________________________________
!______________________________________________________________________________________________________________
!&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(
!_________________________ Monitor output of initialization process _______________________________
!&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(
      if(amyid == amstr) then
         write(*, "()")
         write(*, "(16x, 'InitExpHmltK: Initialization of exp(-/+dt*H_0) and exp(-/+dt*H_0/2) matrices!')")
      end if
!**************************************************************************************************     
!___________________ 0. Exp(-/+dt*H_0) and Exp(-/+dt*H_0/2) matrices by two methods _______________
!**************************************************************************************************
!________________________________________________________________________________________      
!_________________ (0) Apply FFT method method for kinetic propagating __________________
!________________________________________________________________________________________
      if(FFTEXPDTH0) then
!____________________________________________________________________________      
!________________ [0] Output the information ________________________________
!____________________________________________________________________________
         if(amyid == amstr) then
            write(*, "(30x, 'Apply FFT method for exp(-/+dt*H_0) and exp(-/+dt*H_0/2)!')")
         end if
!____________________________________________________________________________      
!________________ [1] Allocate the necessary matrices and vectors ___________
!____________________________________________________________________________ 
         allocate(H0_EgValue(NumNS, NmSpn   )); H0_EgValue = 0.0_rp
         allocate(ExpdtEofH0(NumNS, NmSpn, 4)); ExpdtEofH0 = 0.0_rp
!____________________________________________________________________________      
!________________ [2] Prepare FFT for for kinetic propagating _______________
!____________________________________________________________________________     
         if(.not. FFTEXPDTHT) call FFTSettingBgn()
         call ExpH0kEgVlFFT()
!________________________________________________________________________________________      
!_________________ (1) Apply matrix product method for kinetic propagating ______________
!________________________________________________________________________________________         
      else   
!____________________________________________________________________________      
!________________ [0] Output the information ________________________________
!____________________________________________________________________________
         if(amyid == amstr) then
            write(*, "(30x, 'Apply DGEMM method for exp(-/+dt*H_0) and exp(-/+dt*H_0/2)!')")
         end if
!____________________________________________________________________________      
!________________ [1] Allocate the necessary matrices and vectors ___________
!____________________________________________________________________________   
         allocate(H0_EgValue(NumNS,        NmSpn   )); H0_EgValue = 0.0_rp
         allocate(H0_EgVctor(NumNS, NumNS, NmSpn   )); H0_EgVctor = 0.0_rp
         allocate(ExpdtH0Mat(NumNS, NumNS, NmSpn, 4)); ExpdtH0Mat = 0.0_rp
!____________________________________________________________________________      
!________________ [2] Prepare ZGEMM for exp(-/+dt*H_0(1/2)) matrix __________
!____________________________________________________________________________ 
         call ExpH0kFullMat()
      end if
      
   end subroutine InitExpHmltK
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
  
   
!########################################################################################################################
!########################################################################################################################
!######################################### Exp(-/+dt*H_0(/2)) by FFT method #############################################
!######################################### Exp(-/+dt*H_0(/2)) by FFT method #############################################
!########################################################################################################################
!########################################################################################################################

   
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
   subroutine ExpH0kEgVlFFT()
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  ExpH0kEgVlFFT()
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to prepare some quantities for the FFT calculation of multiplying Exp(-Dltau*K) 
!                   by some matrix.
! KEYWORDS: Prepare for FFT calculation of AMat*exp(-/+dt*K).
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION: Mainly Includes to things:
!         (0) Exp(-dt*\Lambda), where Lambda is the diagonal eigenvalue matrix for H_0. Here, the eigen energies 
!                must be in the correct order for FFT calculations;
!         (1) The FFT transforms the real space matrix into reciprocal space, and it can only guarantee the 
!                reciprocal space matrix is diagonal against to k, not necessarily to spin. So if the model 
!                Hamiltonian has spin-flip terms, we also need to find the matrix diagonalizing the matrix
!                in spin space.
!
!     Input:  (none)   Output: (none)
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________     
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
      use RealPrecsn
      use CoreParamt
      use StdInOutSt
      use MPISetting
      implicit none
!______________________________________________________________________________________________________________
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer I1, I1p, I1m, I2, Ix, Iy, IndK
      integer SpnInd
      real(rp) KxUp, KyUp, KxDn, KyDn
      real(rp) E_FNN_Hop_Up, E_SNN_Hop_Up, E_TNN_Hop_Up
      real(rp) E_FNN_Hop_Dn, E_SNN_Hop_Dn, E_TNN_Hop_Dn
      real(rp), allocatable :: AllEigEng(:)
!______________________________________________________________________________________________________________     
!___________________________  Calculate exponential hopping matrices by FFT method ____________________________
!______________________________________________________________________________________________________________
!**************************************************************************************************     
!___________________ 0. Calculate exp(-/+dt*K) and exp(-/+dt*K/2) matrices ________________________
!************************************************************************************************** 
!________________________________________________________________________________________      
!_________________ (0) Get the eigenvalue of H_0 according to FFT style _________________
!________________________________________________________________________________________
      IndK = 0
      do I2 = 0, NumL2-1, +1
         KyUp = dble(I2) * 2.0_rp * rp_pi / dble(NumL2)
         KyDn = dble(I2) * 2.0_rp * rp_pi / dble(NumL2)
         if(KyUp > rp_pi) KyUp = KyUp - 2.0_rp*rp_pi
         if(KyDn > rp_pi) KyDn = KyDn - 2.0_rp*rp_pi
         do I1 = 0, NumL1/2, +1
            IndK = IndK + 1
!____________________________________________________________________________      
!________________ [0] The Kx, Ky point \in (-pi, pi] region _________________
!____________________________________________________________________________
            KxUp = dble(I1) * 2.0_rp * rp_pi / dble(NumL1)
            KxDn = dble(I1) * 2.0_rp * rp_pi / dble(NumL1)
            if(KxUp > rp_pi) KxUp = KxUp - 2.0_rp*rp_pi
            if(KxDn > rp_pi) KxDn = KxDn - 2.0_rp*rp_pi
!____________________________________________________________________________      
!________________ [1] The dispersion for NN hopping term ____________________
!____________________________________________________________________________
            E_FNN_Hop_Up = 2.0_rp * Hopt1Up * ( cos(KxUp) + cos(KyUp) )
            E_FNN_Hop_Dn = 2.0_rp * Hopt1Dn * ( cos(KxDn) + cos(KyDn) )
!____________________________________________________________________________      
!________________ [2] The dispersion for NNN hopping term ___________________
!____________________________________________________________________________
            E_SNN_Hop_Up = 4.0_rp * Hopt2 * cos(KxUp) * cos(KyUp)
            E_SNN_Hop_Dn = 4.0_rp * Hopt2 * cos(KxDn) * cos(KyDn)
!____________________________________________________________________________      
!________________ [3] The dispersion for 3NN hopping term ___________________
!____________________________________________________________________________
            E_TNN_Hop_Up = 2.0_rp * Hopt3 * ( cos(2.0_rp*KxUp) + cos(2.0_rp*KyUp) )
            E_TNN_Hop_Dn = 2.0_rp * Hopt3 * ( cos(2.0_rp*KxDn) + cos(2.0_rp*KyDn) )
!____________________________________________________________________________      
!________________ [4] Obtain the exponential eigenvalues ____________________
!____________________________________________________________________________
            H0_EgValue(IndK, 1) = E_FNN_Hop_Up + E_SNN_Hop_Up + E_TNN_Hop_Up + ZmFdz/2.0_rp
            H0_EgValue(IndK, 2) = E_FNN_Hop_Dn + E_SNN_Hop_Dn + E_TNN_Hop_Dn - ZmFdz/2.0_rp
!____________________________________________________________________________      
!________________ [5] Obtain the exponential EigVal --> ExpdtEofH0 __________
!____________________________________________________________________________
            do SpnInd = 1, NmSpn, +1
               ExpdtEofH0(IndK, SpnInd, 1) = exp( - Dltau * H0_EgValue(IndK, SpnInd)          )
               ExpdtEofH0(IndK, SpnInd, 2) = exp( + Dltau * H0_EgValue(IndK, SpnInd)          )
               ExpdtEofH0(IndK, SpnInd, 3) = exp( - Dltau * H0_EgValue(IndK, SpnInd) / 2.0_rp )
               ExpdtEofH0(IndK, SpnInd, 4) = exp( + Dltau * H0_EgValue(IndK, SpnInd) / 2.0_rp ) 
            enddo
         enddo
      enddo
!________________________________________________________________________________________      
!_________________ (1) Scale ExpdtEofH0 by 1.0_rp/dble(NumNS) for FFT use _______________
!________________________________________________________________________________________
      ExpdtEofH0 = ExpdtEofH0 / dble(NumNS)
!________________________________________________________________________________________      
!_________________ (2) Sort the eigenvalues for both spin-up and spin-down ______________
!________________________________________________________________________________________
      allocate(AllEigEng(NumNS))
      do SpnInd = 1, NmSpn, +1
         ! Ix = 0, Iy \in [0, NumL2-1]
         Ix = 0
         do Iy = 0, NumL2-1, +1
            I1  = Iy*(NumL1/2+1) + Ix + 1
            I1p = Iy*NumL1 + Ix + 1
            AllEigEng(I1p) = H0_EgValue(I1, SpnInd)
         enddo
         ! Iy = 0, Ix \in [1, NumL1-1]
         Iy = 0
         do Ix = 1, NumL1/2, +1
            I1  = Ix + 1
            I1p =         Ix + 1
            I1m = NumL1 - Ix + 1
            AllEigEng(I1p) = H0_EgValue(I1, SpnInd)
            AllEigEng(I1m) = H0_EgValue(I1, SpnInd)
         enddo
         ! Ix \in [1, NumL1-1], Iy \in [1, NumL2-1]
         do Iy = 1, NumL2-1, +1
            do Ix = 1, NumL1/2, +1
               I1  = Iy *(NumL1/2+1) + Ix + 1
               I1p =        Iy * NumL1 +         Ix + 1
               I1m = (NumL2-Iy)* NumL1 + NumL1 - Ix + 1
               AllEigEng(I1p) = H0_EgValue(I1, SpnInd)
               AllEigEng(I1m) = H0_EgValue(I1, SpnInd)
            enddo
         enddo
         H0_EgValue(1:NumNS, SpnInd) = AllEigEng(1:NumNS)
         call QuckSortR(1, NumNS, H0_EgValue(1, SpnInd))
      enddo
      if(allocated(AllEigEng)) deallocate(AllEigEng)
!________________________________________________________________________________________      
!_________________ (3) Output energy of H_0 Hamiltonian _________________________________
!________________________________________________________________________________________ 
      if(amyid == amstr) then 
         open( 291, file = "Output/00_NonInteractBand.txt", access = "append")
         write(291, "('_________________________________________________________________________')")
         write(291, "('@@@@@@@@@@@@@@@@@@ Single-particle Energy levels of H_0 @@@@@@@@@@@@@@@@@')")
         write(291, "('_________________________________________________________________________')")
!____________________________________________________________________________      
!________________ [0] For The spin-up part of H_0 ___________________________
!____________________________________________________________________________
         write(291, "('ExpH0kEgVlFFT --> Decoupled spin-up part in H_0:')")
         write(291, "()")
         do I1 = 1, NumNC, +1
            write(291, "(I6, A, es25.16)") I1, char(9), H0_EgValue(I1, 1)
         enddo
         if(IfFixnT) then
            write(291, "()")
            write(291, "('Total Energy = ', es25.16)") sum(H0_EgValue(1:NumNe/2, 1))
            write(291, "('  Energy gap = ', es25.16)") (H0_EgValue(NumNe/2+1, 1)-H0_EgValue(NumNe/2, 1))/2.0_rp
         end if
         write(291, "()")
         write(291, "()")
!____________________________________________________________________________      
!________________ [1] For The spin-down part of H_0 _________________________
!____________________________________________________________________________
         write(291, "('ExpH0kEgVlFFT --> Decoupled spin-down part in H_0:')")
         write(291, "()")
         do I1 = 1, NumNC, +1
            write(291, "(I6, A, es25.16)") I1, char(9), H0_EgValue(I1, 2)
         enddo
         if(IfFixnT) then
            write(291, "()")
            write(291, "('Total Energy = ', es25.16)") sum(H0_EgValue(1:NumNe/2, 2))
            write(291, "('  Energy gap = ', es25.16)") (H0_EgValue(NumNe/2+1, 2)-H0_EgValue(NumNe/2, 2))/2.0_rp
         end if
         close(291)
      end if

   end subroutine ExpH0kEgVlFFT
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


!########################################################################################################################
!########################################################################################################################
!################################# Exp(-/+dt*H_0(/2)) by Full matrix multiplication #####################################
!################################# Exp(-/+dt*H_0(/2)) by Full matrix multiplication #####################################
!########################################################################################################################
!########################################################################################################################


!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
   subroutine ExpH0kFullMat()
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  ExpH0kFullMat()
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to calculate full/half of exponential kinect matrices.
! KEYWORDS: Exponential kinetic matrices without break up.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION: Both \exp(\pm\Delta\tau*K) and \exp(\pm\Delta\tau*K/2) are obtained.
!
!     Input:  (none). Output: (none).
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________     
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
      use RealPrecsn
      use CoreParamt
      use StdInOutSt
      use MPISetting
      implicit none
!______________________________________________________________________________________________________________
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer I0, I1, I2, SpnInd
      real(rp) Rtp0(4)
      real(rp), allocatable :: TmpMat(:, :, :)
!______________________________________________________________________________________________________________     
!___________________________  Calculate exponential hopping matrices __________________________________________
!______________________________________________________________________________________________________________
!**************************************************************************************************     
!___________________ 0. Allocate the matrices used in the following _______________________________
!**************************************************************************************************
      allocate(TmpMat(NumNS, NumNS, NmSpn)); TmpMat = 0.0_rp
!**************************************************************************************************     
!___________________ 1. Obtain the H_0 Hamiltonian matrix and diagonalize it ______________________
!**************************************************************************************************
!________________________________________________________________________________________      
!_________________ (0) Obtain the tight-binding Hamiltonian matrix ______________________
!________________________________________________________________________________________
      call GenerateH0Mat(TmpMat)
!________________________________________________________________________________________      
!_________________ (1) Diagonalize the tight-binding Hamiltonian matrix _________________
!________________________________________________________________________________________   
      H0_EgValue = 0.0_rp; H0_EgVctor = 0.0_rp
      call dMat_Diag_QMC(NumNS, TmpMat(1, 1, 1), H0_EgValue(1, 1), H0_EgVctor(1, 1, 1))
!________________________________________________________________________________________      
!_________________ (2) Output energy of H_0 Hamiltonian _________________________________
!________________________________________________________________________________________
      if(amyid == amstr) then
         open( 291, file = "Output/00_NonInteractBand.txt", access = "append")
         write(291, "('_________________________________________________________________________')")
         write(291, "('@@@@@@@@@@@@@@@@@@ Single-particle Energy levels of H_0 @@@@@@@@@@@@@@@@@')")
         write(291, "('_________________________________________________________________________')")
!____________________________________________________________________________      
!________________ [0] For The spin-up part of H_0 ___________________________
!____________________________________________________________________________
         write(291, "('ExpH0kFullMat --> Decoupled spin-up part in H_0:')")
         write(291, "()")
         do I1 = 1, NumNS, +1
            write(291, "(I6, A, es25.16)") I1, char(9), H0_EgValue(I1, 1)
         enddo
         if(IfFixnT) then
            write(291, "()")
            write(291, "('Total Energy = ', es25.16)") sum(H0_EgValue(1:NumNe/2, 1))
            write(291, "('  Energy gap = ', es25.16)") (H0_EgValue(NumNe/2+1, 1)-H0_EgValue(NumNe/2, 1))/2.0_rp
         end if
         write(291, "()")
         write(291, "()")
!____________________________________________________________________________      
!________________ [1] For The spin-down part of H_0 _________________________
!____________________________________________________________________________
         write(291, "('ExpH0kFullMat --> Decoupled spin-down part in H_0:')")
         write(291, "()")
         do I1 = 1, NumNS, +1
            write(291, "(I6, A, es25.16)") I1, char(9), H0_EgValue(I1, 2)
         enddo
         if(IfFixnT) then
            write(291, "()")
            write(291, "('Total Energy = ', es25.16)") sum(H0_EgValue(1:NumNe/2, 2))
            write(291, "('  Energy gap = ', es25.16)") (H0_EgValue(NumNe/2+1, 2)-H0_EgValue(NumNe/2, 2))/2.0_rp
         end if
         close(291)
      end if
!**************************************************************************************************     
!___________________ 2. The exp(-/+dt*H_0) and exp(-/+dt*H_0/2) matrices __________________________
!______________________ exp(-/+dt*H_0  ) = U * exp(-/+dt*\Lambda  ) * U^+ _________________________
!______________________ exp(-/+dt*H_0/2) = U * exp(-/+dt*\Lambda/2) * U^+ _________________________
!************************************************************************************************** 
!________________________________________________________________________________________      
!_________________ (0) exp(-/+dt*\Lambda  ) * U^+ _______________________________________
!_____________________ exp(-/+dt*\Lambda/2) * U^+ _______________________________________
!________________________________________________________________________________________
      ExpdtH0Mat = 0.0_rp
   !$OMP PARALLEL &
   !$OMP PRIVATE(I1, SpnInd, I2, Rtp0)
   !$OMP DO
      do I1 = 1, NumNS, +1
         do SpnInd = 1, NmSpn, +1
            Rtp0(1) = exp( - Dltau * H0_EgValue(I1, SpnInd)          )
            Rtp0(2) = exp( + Dltau * H0_EgValue(I1, SpnInd)          )
            Rtp0(3) = exp( - Dltau * H0_EgValue(I1, SpnInd) / 2.0_rp )
            Rtp0(4) = exp( + Dltau * H0_EgValue(I1, SpnInd) / 2.0_rp )
            do I2 = 1, NumNS, +1
               ExpdtH0Mat(I1, I2, SpnInd, 1) = Rtp0(1) * H0_EgVctor(I2, I1, SpnInd)
               ExpdtH0Mat(I1, I2, SpnInd, 2) = Rtp0(2) * H0_EgVctor(I2, I1, SpnInd)
               ExpdtH0Mat(I1, I2, SpnInd, 3) = Rtp0(3) * H0_EgVctor(I2, I1, SpnInd)
               ExpdtH0Mat(I1, I2, SpnInd, 4) = Rtp0(4) * H0_EgVctor(I2, I1, SpnInd)
            enddo
         enddo
      enddo
   !$OMP END DO     
   !$OMP END PARALLEL
!________________________________________________________________________________________      
!_________________ (1) U * [exp(-/+dt*\Lambda  ) * U^+] _________________________________
!_____________________ U * [exp(-/+dt*\Lambda/2) * U^+] _________________________________
!________________________________________________________________________________________
      TmpMat = 0.0_rp
      call dMatPrd_NN_QMC(NumNS, NumNS, NumNS, 1.0_rp, H0_EgVctor(1, 1, 1), ExpdtH0Mat(1, 1, 1, 1), &
         & 0.0_rp, TmpMat(1, 1, 1))
      call dMat_Copy_QMC(TmpMat(1, 1, 1), ExpdtH0Mat(1, 1, 1, 1))
      
      TmpMat = 0.0_rp
      call dMatPrd_NN_QMC(NumNS, NumNS, NumNS, 1.0_rp, H0_EgVctor(1, 1, 1), ExpdtH0Mat(1, 1, 1, 2), &
         & 0.0_rp, TmpMat)
      call dMat_Copy_QMC(TmpMat(1, 1, 1), ExpdtH0Mat(1, 1, 1, 2))
      
      TmpMat = 0.0_rp
      call dMatPrd_NN_QMC(NumNS, NumNS, NumNS, 1.0_rp, H0_EgVctor(1, 1, 1), ExpdtH0Mat(1, 1, 1, 3), &
         & 0.0_rp, TmpMat(1, 1, 1))
      call dMat_Copy_QMC(TmpMat(1, 1, 1), ExpdtH0Mat(1, 1, 1, 3))
      
      TmpMat = 0.0_rp
      call dMatPrd_NN_QMC(NumNS, NumNS, NumNS, 1.0_rp, H0_EgVctor(1, 1, 1), ExpdtH0Mat(1, 1, 1, 4), &
         & 0.0_rp, TmpMat(1, 1, 1))
      call dMat_Copy_QMC(TmpMat(1, 1, 1), ExpdtH0Mat(1, 1, 1, 4)) 
!**************************************************************************************************     
!_________________ 3. Deallocate all the used matrices ____________________________________________
!**************************************************************************************************
      if(allocated(TmpMat)) deallocate(TmpMat) 
      
   end subroutine ExpH0kFullMat
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$



!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
   subroutine GenerateH0Mat(HmltM)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  GenerateH0Mat(HmltM)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to construct the real space Hamiltonian matrix for H_0 term in the many-body
!                 Hamiltonian we are studying here.
! KEYWORDS: H_0 Hamiltonian matrix.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION: Generate the real space tight-binding Hamiltonian matrix.
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________     
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
      use RealPrecsn
      use RandomNumb
      use CoreParamt
      implicit none
!______________________________________________________________________________________________________________     
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
      real(rp) HmltM(NumNS, NumNS, NmSpn) 
!______________________________________________________________________________________________________________     
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer I0, I1, I2, I3, I4
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      integer tmp, tmp1, tmp2, waveGrid
      real(rp) phaseFactor
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      integer Ix, Iy, SiteParity
      real(rp) Rtp1, Rtp2
!______________________________________________________________________________________________________________     
!_____________________ Main calculations of projector matrix and exponential hopping matrices _________________
!______________________________________________________________________________________________________________
!**************************************************************************************************     
!___________________ 0. Construct the noninteracting Hamiltonian matrix ___________________________
!************************************************************************************************** 
      HmltM = 0.0_rp
!________________________________________________________________________________________      
!_________________ (0) The NN hopping terms _____________________________________________
!________________________________________________________________________________________
      do I0 = 1, NumNS, +1
!____________________________________________________________________________      
!________________ [0] The bond and lattice sites ____________________________
!____________________________________________________________________________
         Ix = StList(I0, 1); Iy = StList(I0, 2)      
         I1 = FNNBond(I0, 1); I2 = FNNBond(I0, 2)
!____________________________________________________________________________      
!________________ [1] Spin-up part of NN hopping ____________________________
!____________________________________________________________________________
         Rtp1 = Hopt1Up * dble(FNNStBnd(I0, 1))
         HmltM(I0, I1, 1) = HmltM(I0, I1, 1) + Rtp1
         HmltM(I1, I0, 1) = HmltM(I1, I0, 1) + Rtp1
         
         Rtp2 = Hopt1Up * dble(FNNStBnd(I0, 2))
         HmltM(I0, I2, 1) = HmltM(I0, I2, 1) + Rtp2
         HmltM(I2, I0, 1) = HmltM(I2, I0, 1) + Rtp2
!____________________________________________________________________________      
!________________ [2] Spin-down part of NN hopping __________________________
!____________________________________________________________________________
         Rtp1 = Hopt1Dn * dble(FNNStBnd(I0, 1))
         HmltM(I0, I1, 2) = HmltM(I0, I1, 2) + Rtp1
         HmltM(I1, I0, 2) = HmltM(I1, I0, 2) + Rtp1

         Rtp2 = Hopt1Dn * dble(FNNStBnd(I0, 2))
         HmltM(I0, I2, 2) = HmltM(I0, I2, 2) + Rtp2
         HmltM(I2, I0, 2) = HmltM(I2, I0, 2) + Rtp2
      enddo
!________________________________________________________________________________________      
!_________________ (1) The 2NN hopping terms ____________________________________________
!________________________________________________________________________________________
      if( abs(Hopt2) > rp_Eps ) then
!*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&
!________________ For uniform type of t2 hopping --> Fermi surface ________________
!*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&*&
         do I0 = 1, NumNS, +1
!____________________________________________________________________________      
!________________ [0] The bond and lattice sites ____________________________
!____________________________________________________________________________
            Ix = StList(I0, 1); Iy = StList(I0, 2)   
            I1 = SNNBond(I0, 1); I2 = SNNBond(I0, 2)
!____________________________________________________________________________      
!________________ [1] Spin-up part of NNN hopping ___________________________
!____________________________________________________________________________
            Rtp1 = Hopt2 * dble(SNNStBnd(I0, 1))
            HmltM(I0, I1, 1) = HmltM(I0, I1, 1) + Rtp1
            HmltM(I1, I0, 1) = HmltM(I1, I0, 1) + Rtp1
               
            Rtp2 = Hopt2 * dble(SNNStBnd(I0, 2))
            HmltM(I0, I2, 1) = HmltM(I0, I2, 1) + Rtp2
            HmltM(I2, I0, 1) = HmltM(I2, I0, 1) + Rtp2
!____________________________________________________________________________      
!________________ [2] Spin-down part of NNN hopping _________________________
!____________________________________________________________________________  
            Rtp1 = Hopt2 * dble(SNNStBnd(I0, 1))
            HmltM(I0, I1, 2) = HmltM(I0, I1, 2) + Rtp1
            HmltM(I1, I0, 2) = HmltM(I1, I0, 2) + Rtp1
               
            Rtp2 = Hopt2 * dble(SNNStBnd(I0, 2))
            HmltM(I0, I2, 2) = HmltM(I0, I2, 2) + Rtp2
            HmltM(I2, I0, 2) = HmltM(I2, I0, 2) + Rtp2 
         enddo
      end if
!________________________________________________________________________________________      
!_________________ (2) The 3NN hopping terms ____________________________________________
!________________________________________________________________________________________
      if( abs(Hopt3) > rp_Eps ) then
         do I0 = 1, NumNS, +1
!____________________________________________________________________________      
!________________ [0] The bond and lattice sites ____________________________
!____________________________________________________________________________
            Ix = StList(I0, 1); Iy = StList(I0, 2)
            I1 = TNNBond(I0, 1); I2 = TNNBond(I0, 2)
!____________________________________________________________________________      
!________________ [1] Spin-up part of NN hopping ____________________________
!____________________________________________________________________________
            Rtp1 = Hopt3 * dble(TNNStBnd(I0, 1))
            HmltM(I0, I1, 1) = HmltM(I0, I1, 1) + Rtp1
            HmltM(I1, I0, 1) = HmltM(I1, I0, 1) + Rtp1
         
            Rtp2 = Hopt3 * dble(TNNStBnd(I0, 2))
            HmltM(I0, I2, 1) = HmltM(I0, I2, 1) + Rtp2
            HmltM(I2, I0, 1) = HmltM(I2, I0, 1) + Rtp2
!____________________________________________________________________________      
!________________ [2] Spin-down part of 3NN hopping _________________________
!____________________________________________________________________________
            Rtp1 = Hopt3 * dble(TNNStBnd(I0, 1))
            HmltM(I0, I1, 2) = HmltM(I0, I1, 2) + Rtp1
            HmltM(I1, I0, 2) = HmltM(I1, I0, 2) + Rtp1
            
            Rtp2 = Hopt3 * dble(TNNStBnd(I0, 2))
            HmltM(I0, I2, 2) = HmltM(I0, I2, 2) + Rtp2
            HmltM(I2, I0, 2) = HmltM(I2, I0, 2) + Rtp2
         enddo
      end if
!________________________________________________________________________________________      
!_________________ (3) The Zeeman field as z-direction magnetic field ___________________
!________________________________________________________________________________________
      if( abs(ZmFdz) > rp_Eps ) then
         do I0 = 1, NumNS, +1
            HmltM(I0, I0, 1) = HmltM(I0, I0, 1) + ZmFdz/2.0_rp
            HmltM(I0, I0, 2) = HmltM(I0, I0, 2) - ZmFdz/2.0_rp
         enddo
      end if
!________________________________________________________________________________________      
!_________________ (4) The pinning field for local order parameters _____________________
!________________________________________________________________________________________
      if( abs(PinSz) >= rp_Eps ) then
!____________________________________________________________________________      
!________________ [0] Pinning AFM Sz along one edge of ribbon _______________
!____________________________________________________________________________
         if(PinSzType == 0) then
            do Iy = 1, NumL2, +1
               SiteParity = (-1)**(mod(Iy, 2))
               Ix = 1
               I1 = (Iy-1)*NumL1 + Ix
               HmltM(I1, I1, 1) = HmltM(I1, I1, 1) + PinSz/2.0_rp * dble(SiteParity)
               HmltM(I1, I1, 2) = HmltM(I1, I1, 2) - PinSz/2.0_rp * dble(SiteParity)
            enddo
!____________________________________________________________________________      
!________________ [1] Pinning AFM Sz along two edges of ribbon ______________
!____________________________________________________________________________
         else if(PinSzType == 1) then
            do Iy = 1, NumL2, +1
               SiteParity = (-1)**(mod(Iy, 2))
         
               Ix = 1
               I1 = (Iy-1)*NumL1 + Ix
               HmltM(I1, I1, 1) = HmltM(I1, I1, 1) + PinSz/2.0_rp * dble(SiteParity)
               HmltM(I1, I1, 2) = HmltM(I1, I1, 2) - PinSz/2.0_rp * dble(SiteParity)
         
               Ix = NumL1
               I2 = (Iy-1)*NumL1 + Ix
               HmltM(I2, I2, 1) = HmltM(I2, I2, 1) - PinSz/2.0_rp * dble(SiteParity)
               HmltM(I2, I2, 2) = HmltM(I2, I2, 2) + PinSz/2.0_rp * dble(SiteParity)
            enddo
!____________________________________________________________________________      
!________________ [2] Pinning AFM Sz at all lattice sites ___________________
!____________________________________________________________________________
         else if(PinSzType == 2) then
            do Ix = 1, NumL1, +1
               do Iy = 1, NumL2, +1
                  SiteParity = (-1)**(mod(Ix+Iy, 2))
                  I1 = (Iy-1)*NumL1 + Ix
                  HmltM(I1, I1, 1) = HmltM(I1, I1, 1) + PinSz/2.0_rp * dble(SiteParity)
                  HmltM(I1, I1, 2) = HmltM(I1, I1, 2) - PinSz/2.0_rp * dble(SiteParity)
               enddo
            enddo
         end if
      end if

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      ! Set up the sinusoidal spin pinning fields
      if (ifSinusoidalPinning) then
         do tmp1 = 1, NumL1, +1
            waveGrid = mod((tmp1 - 1), NumL1)

            do tmp2 = 1, NumL2, +1
               tmp = (tmp2 - 1) * NumL1 + tmp1
               phaseFactor = (-1.0_rp) ** (tmp1 + tmp2)
               HmltM(tmp, tmp, 1) = HmltM(tmp, tmp, 1) &
                  &+ phaseFactor * SinusoidalPinSz/2.0_rp * cos((2.0_rp * rp_pi / LambdaSz) * waveGrid + rp_pi)
               HmltM(tmp, tmp, 2) = HmltM(tmp, tmp, 2) &
                  &- phaseFactor * SinusoidalPinSz/2.0_rp * cos((2.0_rp * rp_pi / LambdaSz) * waveGrid + rp_pi)
            end do
         end do
      end if

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      
   end subroutine GenerateH0Mat
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$