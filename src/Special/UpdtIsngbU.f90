!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! PROGRAM: Several subroutines used to choose (or update) auxiliary fields of H_U term in the model Hamiltonian, as 
!              URght --> Exp(-\Delta\tau H_U) * URght, and also update the weights.
!              By the local update method, as well as the force-bias update method.
! COMMENT: Choose or Update auxiliary fields.
! AUTHOR:  Yuan-Yao He
! DATE:    2020-02-27
! PURPOSE: Different subroutines are introduced as following:
!
!   The process of H_U propagation includes several parts:
!         (0) Calculate N = \tilde{p}(x=+1) + \tilde{p}(x=-1);
!         (1) Choose the auxiliary field by the heat-bath algorithm;
!         (2) Update weights, as well as the Green's function;
!  
!   UpdatHubbU --> Subroutine used to perform the choosing of H_U term, by local update method.
!
!   UpdtIsngbU_LocalSt --> Update by local updates as site by site;
!   UpdtIsngbU_Delayed --> Update by delayed updates;
!   UpdtIsngbU_FrcBias --> Update by force-bias updates.
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
	subroutine UpdtIsngbU(Iwalk, NT)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  UpdtIsngbU(Iwalk, NT)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to perform the orderedly local update process of Ising fields for HubbU 
!                   interaction term.
! KEYWORDS: Updating pf Ising fields in HubbU interaction term.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Orderedly local update of Ising fields in HubbU interaction term.
!
!     Input: Iwalk --> Integer index of present random walker;
!            NT    --> Integer index of imaginary time slice. 
!            
!     Outpt: (none).
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________	  
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
		use RealPrecsn
      use TimeRecord
      use QMCTimeRec
		use CoreParamt
		implicit none
!______________________________________________________________________________________________________________	  
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
      integer Iwalk, NT
!______________________________________________________________________________________________________________	  
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
		integer(8) time1, time2
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
!_________________ Counting calling times and time consumed for HubbU updating process ________________________
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
		TimsUptbU = TimsUptbU + 1
		call system_clock(time1)
!______________________________________________________________________________________________________________	  
!___________________________ Main calculations of HubbU auxiliary fields updates ______________________________
!______________________________________________________________________________________________________________
!**************************************************************************************************	  
!___________________ 0. The initialization for the updating process in NT slice ___________________
!**************************************************************************************************
!________________________________________________________________________________________ 	  
!_________________ (0) Check weight of walker to decide whether to procceed _____________
!_____________________ If weight <= 0, simply kill present walker and return ____________
!________________________________________________________________________________________
      if(WghtProc(Iwalk) <= 0.0_rp) then
         return
      end if
!________________________________________________________________________________________ 	  
!_________________ (1) Initialize normalization factor from updating ____________________
!________________________________________________________________________________________
      UpdtRtTotl = 1.0_rp
!**************************************************************************************************	  
!___________________ 1. Update the auxiliary fields for HubbU interaction  ________________________
!**************************************************************************************************
!________________________________________________________________________________________ 	  
!_________________ (0) UpdtMethod == 0 --> Apply local update method ____________________
!________________________________________________________________________________________
      if(UpdtMethod == 0) then
         call UpdtIsngbU_Local(Iwalk, NT)
!________________________________________________________________________________________ 	  
!_________________ (1) UpdtMethod == 1 --> Apply delayed method _________________________
!________________________________________________________________________________________
      else if(UpdtMethod == 1) then
         call UpdtIsngbU_Delayed(Iwalk, NT)
!________________________________________________________________________________________ 	  
!_________________ (2) UpdtMethod == 2 --> Apply force-bias method ______________________
!________________________________________________________________________________________
      else if(UpdtMethod == 2) then
         call UpdtIsngbU_FrcBias(Iwalk, NT)
      end if
!**************************************************************************************************	  
!___________________ 2. Obtain the Max and Min of UpdtRtTotl for all walkers ______________________
!**************************************************************************************************
      !!!!!!!!!! The Maximum of UpdtRtTotl
      if(UpdtRtTotl > UpdtRtTotMax) then
         UpdtRtTotMax = UpdtRtTotl
      end if
      !!!!!!!!!! The Minimum of UpdtRtTotl
      if(UpdtRtTotl < UpdtRtTotMin) then
         UpdtRtTotMin = UpdtRtTotl
      end if
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
!_________________ Counting calling times and time consumed for HubbU updating process ________________________
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
		call system_clock(time2)
      TimeUptbU = TimeUptbU + TimeIntrvl(time1, time2)

   end subroutine UpdtIsngbU
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


!########################################################################################################################
!########################################################################################################################
!################################################# For Local Update Version #############################################
!################################################# For Local Update Version #############################################
!########################################################################################################################
!########################################################################################################################
   
   
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
	subroutine UpdtIsngbU_Local(Iwalk, NT)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  UpdtIsngbU_Local(Iwalk, NT)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to perform the orderedly local update process of Ising fields for HubbU 
!                   interaction term.
! KEYWORDS: Updating pf Ising fields in HubbU interaction term.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Orderedly local update of Ising fields in HubbU interaction term.
!
!     Input: Iwalk --> Integer index of present random walker;
!            NT    --> Integer index of imaginary time slice. 
!            
!     Outpt: (none).
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________	  
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
		use RealPrecsn
      use RandomNumb
		use CoreParamt
		implicit none
!______________________________________________________________________________________________________________	  
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
      integer Iwalk, NT
!______________________________________________________________________________________________________________	  
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
		integer I0, ISite, AuxiField, SpnInd
      real(rp) Ratio_Re(-1:+1) 
      real(rp) RatioTot, Rtp1
      real(rp) DeltaCof(NmSpn, -1:+1)
      real(rp) RatioMat(NmSpn, -1:+1)
      real(rp) DetMCRat(-1:+1)
		real(rp), allocatable :: TmpMatrix1(:, :)   ! Temporary real vector
		real(rp), allocatable :: TmpMatrix2(:, :)   ! Temporary real vector
!______________________________________________________________________________________________________________	  
!_______________________________ Main calculations of HubbU interaction local updating ________________________
!______________________________________________________________________________________________________________
!**************************************************************************************************	  
!___________________ 0. Check the weight and allocate necessary matrices __________________________
!**************************************************************************************************
!________________________________________________________________________________________ 	  
!_________________ (0) If weight <= 0, simply kill present walker and return ____________
!________________________________________________________________________________________
      if(WghtProc(Iwalk) <= 0.0_rp) then
         return
      end if
!________________________________________________________________________________________ 	  
!_________________ (1) Allocate the matrices used in the following ______________________
!________________________________________________________________________________________
      allocate(TmpMatrix1(NumNS, NmSpn))
      allocate(TmpMatrix2(NumNS, NmSpn)) 
      TmpMatrix1 = 0.0_rp
      TmpMatrix2 = 0.0_rp
!**************************************************************************************************	  
!___________________ 1. Perform the local update, site by site ____________________________________
!**************************************************************************************************
      do ISite = 1, NumNS, +1
!________________________________________________________________________________________ 	  
!_________________ (0) Calculate Metropolis Ratio for x=+1 and x=-1 fields ______________
!____________________ R = det(RatioMat), and RatioMat is 2*2 matrix _____________________
!________________________________________________________________________________________ 
!____________________________________________________________________________ 	  
!________________ [0] Effective 2*2 \Delta matrix for updating ______________
!____________________________________________________________________________        
         DeltaCof(1:NmSpn, -1:+1) = DeltbU_H0T(1:NmSpn, -1:+1, ISite)
!____________________________________________________________________________ 	  
!________________ [1] RatioMat = (I-G) * DeltaCof ___________________________
!____________________ And get the Metropolis Ratio for x=+1 and x=-1 ________
!____________________________________________________________________________
         DetMCRat = 0.0_rp
         do I0 = -1, +1, +2
            do SpnInd = 1, 2, +1
               RatioMat(SpnInd, I0) = ( 1.0_rp - GrnFunct(ISite, ISite, SpnInd, Iwalk) ) * DeltaCof(SpnInd, I0)
            enddo
            DetMCRat(I0) = ( 1.0_rp + RatioMat(1, I0) ) * ( 1.0_rp + RatioMat(2, I0) )
         enddo
!____________________________________________________________________________ 	  
!________________ [2] Pick up Constant from the HS transformations __________
!____________________________________________________________________________
         do I0 = -1, +1, 2
            if(HS_Type == 0) then
               Ratio_Re(I0) = DetMCRat(I0) * exp(+Dltau*HubbU/2.0_rp - LmdbU*dble(I0))
            else
               Ratio_Re(I0) = DetMCRat(I0)
            end if
!&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
!&%&%&%&%&%&%&%&%&%&% Add the Mirror correction for killing walker &%&%&%&%&%&%&%&%&%&%&%
!&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
            if(Ratio_Re(I0) <= 0.0_rp) then
               Ratio_Re(I0) = 0.0_rp
            end if
         enddo
!____________________________________________________________________________ 	  
!________________ [3] Final total Metropolis ratio normalzation _____________
!____________________ And check, and update the weight ______________________
!____________________________________________________________________________
         RatioTot = Ratio_Re(-1) + Ratio_Re(+1)
         if(RatioTot <= 0.0_rp) then
            WghtProc(Iwalk) = +0.0_rp
            Log_Wght(Iwalk) = -1.0E+100_rp
            exit
         else
            ! Log_Wght(Iwalk) = Log_Wght(Iwalk) + UHF_Const(ISite) + log(RatioTot*0.5_rp)
            ! WghtProc(Iwalk) = WghtProc(Iwalk) * exp(UHF_Const(ISite)) * RatioTot*0.5_rp
            Log_Wght(Iwalk) = Log_Wght(Iwalk) + log(RatioTot*0.5_rp)
            WghtProc(Iwalk) = WghtProc(Iwalk) *     RatioTot*0.5_rp
         end if
         UpdtRtTotl = UpdtRtTotl * RatioTot*0.5_rp
!________________________________________________________________________________________ 	  
!_________________ (1) Use the heat-bath algorithm to choose the field x ________________
!________________________________________________________________________________________          
         if( Ratio_Re(-1)/RatioTot >= spring_sfmt_stream() ) then
            AuxiField = -1
         else
            AuxiField = +1
         end if
         IsingbU(ISite, NT, Iwalk) = AuxiField
!________________________________________________________________________________________ 	  
!_________________ (2) Update the Green's Function matrix _______________________________
!________________________________________________________________________________________
         do SpnInd = 1, NmSpn, +1
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$	
!____________ TmpMatrix1(:, 2) = one columns of GrnFunct matrix ___________________________
!____________ TmpMatrix2(2, :) = one rows of (GrnFunct - I) Matrix ________________________
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$
            call dcopy(NumNS, GrnFunct(1, ISite, SpnInd, Iwalk),     1, TmpMatrix1(1, SpnInd), 1)   
            call dcopy(NumNS, GrnFunct(ISite, 1, SpnInd, Iwalk), NumNS, TmpMatrix2(1, SpnInd), 1)
            TmpMatrix2(ISite, SpnInd) = TmpMatrix2(ISite, SpnInd) - 1.0_rp
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$
!____________ The inverse of (I+RatioMat) matrix __________________________________________
!____________ RatioMat = DeltaCof(2, 2) * [(I+RatioMat)(2, 2)]^{-1} _______________________
!____________ TmpMatrix2(2, :) --> RatioMat(2, 2) * TmpMatrix2(2, :) ______________________
!____________ GrnFunct(:, :) = GrnFunct(:, :) + TmpMatrix1(:, 2) * TmpMatrix2(2, :) _______
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$
            Rtp1 = DeltaCof(SpnInd, AuxiField) / ( 1.0_rp + RatioMat(SpnInd, AuxiField) )
            call dMat_VecVecPrd(NumNS, NumNS, Rtp1, TmpMatrix1(1, SpnInd), 1, TmpMatrix2(1, SpnInd), 1, &
               & GrnFunct(1, 1, SpnInd, Iwalk), NumNS)
         enddo
      enddo
!**************************************************************************************************	  
!___________________ 2. Deallocate the necessary matrices used here _______________________________
!**************************************************************************************************
		if(allocated(TmpMatrix1)) deallocate(TmpMatrix1)
		if(allocated(TmpMatrix2)) deallocate(TmpMatrix2)
		
   end subroutine UpdtIsngbU_Local
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


!########################################################################################################################
!########################################################################################################################
!################################################# For Delayed Update Version ###########################################
!################################################# For Delayed Update Version ###########################################
!########################################################################################################################
!########################################################################################################################


!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
	subroutine UpdtIsngbU_Delayed(Iwalk, NT)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  UpdtIsngbU_Delayed(Iwalk, NT)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to perform the updating process of Ising fields for HubbU interaction term.
! KEYWORDS: Updating pf Ising fields in HubbU interaction term.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Updating pf Ising fields in HubbU interaction term.
!
!     Input: Iwalk --> Integer index of present random walker;
!            NT    --> Integer index of imaginary time slice. 
!            
!     Outpt: (none).
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________	  
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
		use RealPrecsn
      use RandomNumb
		use CoreParamt
		implicit none
!______________________________________________________________________________________________________________	  
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
      integer Iwalk, NT
!______________________________________________________________________________________________________________	  
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer I0, ISite, AuxiField, SpnInd
      integer BlockDim                    
      real(rp) Ratio_Re(-1:+1) 
      real(rp) RatioTot, Rtp1
      real(rp) DeltaCof(NmSpn, -1:+1)
      real(rp) RatioMat(NmSpn, -1:+1)
      real(rp) DetMCRat(-1:+1)
      real(rp), allocatable :: AllRatMat(:, :   ) ! The diagonal 2*2 matrices of Green's function 
      real(rp), allocatable :: RowMatrix(:, :, :) ! To store the rows    of diagonal Green's function
      real(rp), allocatable :: ColMatrix(:, :, :) ! To store the columns of diagonal Green's function
!______________________________________________________________________________________________________________	  
!_______________________________ Main calculations of HubbU interaction delayed updating ______________________
!______________________________________________________________________________________________________________ 
!**************************************************************************************************	  
!___________________ 0. Allocate necessary matrices and initializations ___________________________
!**************************************************************************************************
!________________________________________________________________________________________ 	  
!_________________ (0) Allocate all the matrices ________________________________________
!________________________________________________________________________________________
      !!!!!!!!!! The diagonal elements of Green's function matrix
      allocate(AllRatMat(NmSpn, NumNS))
      AllRatMat = 0.0_rp
      !!!!!!!!!! Rows and columns used to update Green's function
      allocate(RowMatrix(NblkUDelay, NumNS, NmSpn))
      allocate(ColMatrix(NumNS, NblkUDelay, NmSpn))
      RowMatrix = 0.0_rp
      ColMatrix = 0.0_rp
      !!!!!!!!!! The block dimension of delayed update
      BlockDim = 0
!________________________________________________________________________________________ 	  
!_________________ (1) Initialize AllRatMat(2, NumNS) matrices __________________________
!________________________________________________________________________________________
      do I0 = 1, NumNS, +1
         do SpnInd = 1, NmSpn, +1
            AllRatMat(SpnInd, I0) = GrnFunct(I0, I0, SpnInd, Iwalk)
         enddo
      enddo
!**************************************************************************************************	  
!___________________ 1. Update Ising fields using delayed updating method _________________________
!**************************************************************************************************
		do ISite = 1, NumNS, +1
!________________________________________________________________________________________ 	  
!_________________ (0) Calculate Metropolis Ratio for x=+1 and x=-1 fields ______________
!____________________ R = det(RatioMat), and RatioMat is 2*2 matrix _____________________
!________________________________________________________________________________________ 
!____________________________________________________________________________ 	  
!________________ [0] Effective 2*2 \Delta matrix for updating ______________
!____________________________________________________________________________        
         DeltaCof(1:NmSpn, -1:+1) = DeltbU_H0T(1:NmSpn, -1:+1, ISite)
!____________________________________________________________________________ 	  
!________________ [1] RatioMat = (I-G) * DeltaCof ___________________________
!____________________ And get the Metropolis Ratio for x=+1 and x=-1 ________
!____________________________________________________________________________
         DetMCRat = 0.0_rp
         do I0 = -1, +1, +2
            do SpnInd = 1, 2, +1
               RatioMat(SpnInd, I0) = ( 1.0_rp - AllRatMat(SpnInd, ISite) ) * DeltaCof(SpnInd, I0)
            enddo
            DetMCRat(I0) = ( 1.0_rp + RatioMat(1, I0) ) * ( 1.0_rp + RatioMat(2, I0) )
         enddo
!____________________________________________________________________________ 	  
!________________ [2] Pick up Constant from the HS transformations __________
!____________________________________________________________________________
         do I0 = -1, +1, 2
            if(HS_Type == 0) then
               Ratio_Re(I0) = DetMCRat(I0) * exp(+Dltau*HubbU/2.0_rp - LmdbU*dble(I0))
            else
               Ratio_Re(I0) = DetMCRat(I0)
            end if
!&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
!&%&%&%&%&%&%&%&%&%&% Add the Mirror correction for killing walker &%&%&%&%&%&%&%&%&%&%&%
!&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
            if(Ratio_Re(I0) <= 0.0_rp) then
               Ratio_Re(I0) = 0.0_rp
            end if
         enddo
!____________________________________________________________________________ 	  
!________________ [3] Final total Metropolis ratio normalzation _____________
!____________________ And check, and update the weight ______________________
!____________________________________________________________________________
         RatioTot = Ratio_Re(-1) + Ratio_Re(+1)
         if(RatioTot <= 0.0_rp) then
            WghtProc(Iwalk) = +0.0_rp
            Log_Wght(Iwalk) = -1.0E+100_rp
            exit
         else
            ! Log_Wght(Iwalk) = Log_Wght(Iwalk) + UHF_Const(ISite) + log(RatioTot*0.5_rp)
            ! WghtProc(Iwalk) = WghtProc(Iwalk) * exp(UHF_Const(ISite)) * RatioTot*0.5_rp
            Log_Wght(Iwalk) = Log_Wght(Iwalk) + log(RatioTot*0.5_rp)
            WghtProc(Iwalk) = WghtProc(Iwalk) *     RatioTot*0.5_rp
         end if
         UpdtRtTotl = UpdtRtTotl * RatioTot*0.5_rp
!________________________________________________________________________________________ 	  
!_________________ (1) Use the heat-bath algorithm to choose the field x ________________
!________________________________________________________________________________________          
         if( Ratio_Re(-1)/RatioTot >= spring_sfmt_stream() ) then
            AuxiField = -1
         else
            AuxiField = +1
         end if
         IsingbU(ISite, NT, Iwalk) = AuxiField
!________________________________________________________________________________________ 	  
!_________________ (2) Accumulate the block dimension ___________________________________
!________________________________________________________________________________________
         BlockDim = BlockDim + 1
!________________________________________________________________________________________ 	  
!_________________ (3) Prepare for the delayed update process ___________________________
!________________________________________________________________________________________
         do SpnInd = 1, NmSpn, +1
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$	
!____________ The inverse of (I+RatioMat) matrix __________________________________________
!____________ RatioMat = DeltaCof(2, 2) * [(I+RatioMat)(2, 2)]^{-1} _______________________
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$	
            Rtp1 = DeltaCof(SpnInd, AuxiField) / ( 1.0_rp + RatioMat(SpnInd, AuxiField) )
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$	  
!____________ Obtain the two rows used for delayed updates ________________________________
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$  
            call dcopy(NumNS, GrnFunct(ISite, 1, SpnInd, Iwalk), NumNS, RowMatrix(BlockDim, 1, SpnInd), NblkUDelay)
            do I0 = 1, BlockDim-1, +1
               call daxpy(NumNS, ColMatrix(ISite, I0, SpnInd), RowMatrix(I0, 1, SpnInd), NblkUDelay, &
                  & RowMatrix(BlockDim, 1, SpnInd), NblkUDelay)
            enddo
            RowMatrix(BlockDim, ISite, SpnInd) = RowMatrix(BlockDim, ISite, SpnInd) - 1.0_rp
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$	  
!____________ Obtain the two columns used for delayed updates _____________________________
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$
            call dcopy(NumNS, GrnFunct(1, ISite, SpnInd, Iwalk), 1, ColMatrix(1, BlockDim, SpnInd), 1)
            do I0 = 1, BlockDim-1, +1
               call daxpy(NumNS, RowMatrix(I0, ISite, SpnInd), ColMatrix(1, I0, SpnInd), 1, &
                  & ColMatrix(1, BlockDim, SpnInd), 1)
            enddo
            call dscal(NumNS, Rtp1, ColMatrix(1, BlockDim, SpnInd), 1)
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$	  
!____________ Update all the diagonal 2*2 matrices in GrnFunct ____________________________
!**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$**&&$$
            do I0 = 1, NumNS, +1
               AllRatMat(SpnInd, I0) = AllRatMat(SpnInd, I0) + &
                              & ColMatrix(I0, BlockDim, SpnInd) * RowMatrix(BlockDim, I0, SpnInd)
            enddo
         enddo
!________________________________________________________________________________________ 	  
!_________________ (4) Update the whole Green function matrix ___________________________
!_____________________ when the dimension of RowMatrix and ColMatrix ____________________
!_____________________ reach the value set in for the simulation ________________________
!________________________________________________________________________________________
         if( (BlockDim == NblkUDelay) .or. (ISite == NumNS) ) then
!____________________________________________________________________________ 	  
!________________ [0] Perform the final update of GrnFunct matrix ___________
!____________________________________________________________________________ 
            do SpnInd = 1, NmSpn, +1
               call dMatPrdAll("N", "N", NumNS, NumNS, BlockDim, 1.0_rp, ColMatrix(1, 1, SpnInd), NumNS, &
                  & RowMatrix(1, 1, SpnInd), NblkUDelay, 1.0_rp, GrnFunct(1, 1, SpnInd, Iwalk), NumNS)
            enddo
!____________________________________________________________________________ 	  
!________________ [1] Reset all the related quantities ______________________
!____________________________________________________________________________
            if( ISite < NumNS ) then
               !!!!!!!!!! For the BlockDim parameter
               BlockDim = 0
               !!!!!!!!!! For ColMatrix and RowMatrix
               ColMatrix = 0.0_rp
               RowMatrix = 0.0_rp
               !!!!!!!!!! For AllRatMa
               do I0 = 1, NumNS, +1
                  do SpnInd = 1, NmSpn, +1
                     AllRatMat(SpnInd, I0) = GrnFunct(I0, I0, SpnInd, Iwalk)
                  enddo
               enddo
            end if
         end if
      enddo
!**************************************************************************************************	  
!___________________ 2. Deallocate the necessary matrices used here _______________________________
!**************************************************************************************************
		if(allocated(ColMatrix)) deallocate(ColMatrix)
		if(allocated(RowMatrix)) deallocate(RowMatrix)
      if(allocated(AllRatMat)) deallocate(AllRatMat)
		
   end subroutine UpdtIsngbU_Delayed
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


!########################################################################################################################
!########################################################################################################################
!############################################### For Force-bias Update Version ##########################################
!############################################### For Force-bias Update Version ##########################################
!########################################################################################################################
!########################################################################################################################


!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
	subroutine UpdtIsngbU_FrcBias(Iwalk, NT)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  UpdtIsngbU_FrcBias(Iwalk, NT)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to perform the force-bias update of Ising fields for HubbU interaction term.
! KEYWORDS: Updating of Ising fields in HubbU interaction term.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Force-bias update of Ising fields in HubbU interaction term.
!
!     Input: Iwalk --> Integer index of present random walker;
!            NT    --> Integer index of imaginary time slice. 
!            
!     Outpt: (none).
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________	  
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
		use RealPrecsn
      use RandomNumb
		use CoreParamt
		implicit none
!______________________________________________________________________________________________________________	  
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
      integer Iwalk, NT
!______________________________________________________________________________________________________________	  
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer I0, I1, I2, ISite
      integer AuxiField, SpnInd
      real(rp) HSTerm, niup, nidn
      real(rp) UHFMntTerm, H0TDntyCnt
      real(rp) DetMCRat(-1:+1)
      real(rp) Ratio_Re(-1:+1), RatioTot
      real(rp) AcumltPsbLog, Rtp1, Rtp2
      complex(rp) TotalWghtChgLog, LogzDet
      real(rp), allocatable :: TmpMatrix(:, :, :)  ! The temporary matrix for computing det ratio
!______________________________________________________________________________________________________________	  
!_______________________________ Main calculations of HubbU interaction updating ______________________________
!______________________________________________________________________________________________________________
!**************************************************************************************************	  
!___________________ 0. Initialization of the force-bias update process ___________________________
!**************************************************************************************************
!________________________________________________________________________________________ 	  
!_________________ (0) Allocate temporary matrix for following use ______________________
!________________________________________________________________________________________
      allocate(TmpMatrix(NumNS, NumNS, NmSpn))
      TmpMatrix = 0.0_rp
!________________________________________________________________________________________ 	  
!_________________ (1) AcumltPsbLog for accumulating prior possibility log ______________
!________________________________________________________________________________________ 
      TotalWghtChgLog = 0.0_rp
      AcumltPsbLog = 0.0_rp
!**************************************************************************************************	  
!___________________ 1. Calculate Force bias and choose the fields ________________________________
!**************************************************************************************************
      do ISite = 1, NumNS, +1
!________________________________________________________________________________________ 	  
!_________________ (0) The force bias for this ISite field ______________________________
!________________________________________________________________________________________ 
         niup = 1.0_rp - GrnFunct(ISite, ISite, 1, Iwalk)
         nidn = 1.0_rp - GrnFunct(ISite, ISite, 2, Iwalk)
         if(HS_Type == 0) then
            HSTerm = niup + nidn
         else if(HS_Type == 1) then
            HSTerm = niup - nidn
         end if
         UHFMntTerm = + Dltau * HubbU_UHF * ( MagMoment(ISite, 2)*niup + MagMoment(ISite, 1)*nidn )
         H0TDntyCnt = - Dltau * ( ChemP - ChemP_BT + HubbU_UHF/2.0_rp ) * ( niup + nidn )
!________________________________________________________________________________________ 	  
!_________________ (1) The force bias for this ISite field ______________________________
!________________________________________________________________________________________ 
         do I0 = -1, +1, 2
            Rtp1 = LmdbU * dble(I0) * HSTerm
            DetMCRat(I0) = exp( Rtp1 + UHFMntTerm + H0TDntyCnt )
            if(HS_Type == 0) then
               Ratio_Re(I0) = DetMCRat(I0) * exp(+Dltau*HubbU/2.0_rp - LmdbU*dble(I0))
            else
               Ratio_Re(I0) = DetMCRat(I0)
            end if
         enddo
         RatioTot = Ratio_Re(-1) + Ratio_Re(+1)
!________________________________________________________________________________________ 	  
!_________________ (2) Accumulate the log of the weight change __________________________
!________________________________________________________________________________________
         ! TotalWghtChgLog = TotalWghtChgLog + cmplx(log(RatioTot*0.5_rp)+UHF_Const(ISite), 0.0_rp, rp)
         TotalWghtChgLog = TotalWghtChgLog + cmplx(log(RatioTot*0.5_rp), 0.0_rp, rp)
!________________________________________________________________________________________ 	  
!_________________ (3) Use the heat-bath algorithm to choose the field x ________________
!________________________________________________________________________________________          
         if( Ratio_Re(-1)/RatioTot >= spring_sfmt_stream() ) then
            AuxiField = -1
         else
            AuxiField = +1
         end if
         IsingbU(ISite, NT, Iwalk) = AuxiField
!________________________________________________________________________________________ 	  
!_________________ (4) Accumulate the possibility of choosing field _____________________
!________________________________________________________________________________________ 
         AcumltPsbLog = AcumltPsbLog + log(DetMCRat(AuxiField))
      enddo
!**************************************************************************************************	  
!___________________ 2. Compute ratio between determinants and update GrnFunct matrix _____________
!______________________ R = det[P(1-G)+G] and P = exp(LmdbU*I0) ___________________________________
!______________________ G' = G * [P(1-G)+G]^{-1} __________________________________________________
!**************************************************************************************************
!________________________________________________________________________________________ 	  
!_________________ (0) Calculate TmpMatrix = G + P*(1-G) ________________________________
!________________________________________________________________________________________
      TmpMatrix = 0.0_rp
   !$OMP PARALLEL &
   !$OMP PRIVATE(I2, SpnInd, I1, Rtp1, Rtp2)
   !$OMP DO
      do I2 = 1, NumNS, +1
         do SpnInd = 1, NmSpn, +1
            Rtp2 = DeltbU_H0T(SpnInd, IsingbU(I2, NT, Iwalk), I2) + 1.0_rp
            do I1 = 1, NumNS, +1
               Rtp1 = DeltbU_H0T(SpnInd, IsingbU(I1, NT, Iwalk), I1) + 1.0_rp
               TmpMatrix(I1, I2, SpnInd) = (1.0_rp - Rtp1) * GrnFunct(I1, I2, SpnInd, Iwalk)
            enddo
            TmpMatrix(I2, I2, SpnInd) = TmpMatrix(I2, I2, SpnInd) + Rtp2
         enddo
      enddo
   !$OMP END DO
   !$OMP END PARALLEL
!________________________________________________________________________________________ 	  
!_________________ (1) Compute G' = G*[P(1-G)+G]^{-1} and det[P(1-G)+G] _________________
!________________________________________________________________________________________
      call dMatEqSet_Left_LogDet_QMC(NumNS, NumNS, TmpMatrix(1, 1, 1), GrnFunct(1, 1, 1, Iwalk), LogzDet)
!**************************************************************************************************	  
!___________________ 3. Update the weight and determine whether to proceed or kill ________________
!**************************************************************************************************
!________________________________________________________________________________________ 	  
!_________________ (0) Total weight change == exp(LogzDet-AcumltPsbLog) _________________
!________________________________________________________________________________________
      TotalWghtChgLog = TotalWghtChgLog + LogzDet - cmplx(AcumltPsbLog, 0.0_rp, rp)
!________________________________________________________________________________________ 	  
!_________________ (1) Check real part of exp(TotalWghtChgLog) __________________________
!________________________________________________________________________________________
      if( cos(aimag(TotalWghtChgLog)) <= 0.0_rp ) then
         WghtProc(Iwalk) = +0.0_rp
         Log_Wght(Iwalk) = -1.0E+100_rp
         go to 299
      else
         Log_Wght(Iwalk) = Log_Wght(Iwalk) + real(TotalWghtChgLog) + log(cos(aimag(TotalWghtChgLog)))
         WghtProc(Iwalk) = WghtProc(Iwalk) * exp(real(TotalWghtChgLog)) * cos(aimag(TotalWghtChgLog))
      end if
!________________________________________________________________________________________ 	  
!_________________ (2) Record the real part of exp(TotalWghtChgLog) _____________________
!________________________________________________________________________________________
      UpdtRtTotl = exp(real(TotalWghtChgLog)) * cos(aimag(TotalWghtChgLog))
!**************************************************************************************************	  
!___________________ 4. Finalization of the force-bias update process _____________________________
!**************************************************************************************************
!________________________________________________________________________________________ 	  
!_________________ (0) If Weight encounters zero, kill the walker to exit _______________
!________________________________________________________________________________________
299   continue
!________________________________________________________________________________________ 	  
!_________________ (1) Deallocate temporary matrix used above ___________________________
!________________________________________________________________________________________
      if(allocated(TmpMatrix)) deallocate(TmpMatrix)
		
   end subroutine UpdtIsngbU_FrcBias
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$