!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! PROGRAM: Several subroutines used to perform the additional measurements in [Beta, 0] sweep.
! COMMENT: Perform additional measurements in [Beta, 0] sweep.
! AUTHOR:  Yuan-Yao He
! DATE:    2020-02-27
! PURPOSE: Different subroutines are introduced as following:
!
!    In order to stablize the numerical matrix multiplication, we seperate it into two steps:
!        (0) Perform the sweep as [0, Beta] to store the UDV matrices for Right side;
!        (1) Perform the propagation for left side and the measurements. 
!  
!   SweepM2One --> Subroutine used to perform the additional measurements in [Beta, 0] sweep.
!             
!   SweepForwdDy --> Subroutine used to perform the sweep as [0, Beta] to store the UDV matrices for Right side;
!   SweepBckwdDy --> Subroutine used to perform the propagation for left side and the measurements;
!
!   PropgtURtDynGrF --> Subroutine used to propagate the Green's function matrix, static and dynamic;
!          
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

   

!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
      subroutine SweepM2One(NB, NSW) 
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  SweepM2One(NB, NSW) 
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to perform the additional measurements in the sweep from \tau=M to \tau=1.
! KEYWORDS: M-->1 sweep.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION: Perform the sweep from \tau=M to \tau=1 in every Full sweep
!
!     Input: NB  --> Integer index for BIN simulation;
!            NSW --> Integer index for the sweep.
!
!     Outpt: (none).
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________     
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
      use RealPrecsn
      use RandomNumb
      use TimeRecord
      use QMCTimeRec
            use CoreParamt
            use Observable
            implicit none
!______________________________________________________________________________________________________________     
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
      integer NB, NSW
!______________________________________________________________________________________________________________     
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer(8) time1, time2
            integer WalkIndx, Iwalk, NTtauEq0
!______________________________________________________________________________________________________________     
!_________________________ Main calculations of Sweep from t=1 slice to t=M slice _____________________________
!______________________________________________________________________________________________________________
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
!_________________ Counting calling times and time consumed for Beta --> 0 sweep and measure __________________
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
      TimsM2One = TimsM2One + 1
      call system_clock(time1)
!**************************************************************************************************     
!___________________ 0. Some initializations before the sweep _____________________________________
!**************************************************************************************************
!________________________________________________________________________________________         
!_________________ (0) All the static and dynamic physical observables __________________
!________________________________________________________________________________________
      !!!!!!!!!! For the static measurements
      MeaM2One = 0
      !!!!!!!!!! For the dynamic measurements
      if(IfTAU) then
         NObsDynm = NObsDynm + 1
         RealSpCrFTauSwp = 0.0_rp
      end if
! !________________________________________________________________________________________       
! !_________________ (1) Set the Tau==0 point for dynamic measurements ____________________
! !_____________________ by randomly choosing NT \in [0, LTrot-1] _________________________
! !________________________________________________________________________________________
!       if(IfTAU .and. IfTau0Rand) then
!          NTtauEq0 = floor(spring_sfmt_stream()*LTrot)
!       else
!          NTtauEq0 = 0
!       end if
!**************************************************************************************************     
!___________________ 1. Perform sweeps and measurements for all the random walkers ________________
!**************************************************************************************************         
      do WalkIndx = 1, NWkBt, +1
!________________________________________________________________________________________         
!_________________ (0) The integer index of the present random walker ___________________
!________________________________________________________________________________________
         Iwalk = IdptWkIndx(WalkIndx)
!________________________________________________________________________________________         
!_________________ (1) Set the Tau==0 point for dynamic measurements ____________________
!_____________________ by randomly choosing NT \in [0, LTrot-1] _________________________
!________________________________________________________________________________________
         if(IfTAU .and. IfTau0Rand) then
            NTtauEq0 = floor(spring_sfmt_stream()*LTrot)
         else
            NTtauEq0 = 0
         end if

         ! write(*, *) WalkIndx, Iwalk, NTtauEq0
         ! pause
!________________________________________________________________________________________         
!_________________ (2) Initialize UDV matrices at both right and left sides _____________
!________________________________________________________________________________________
         !!!!!!!!!! For URght, DRghtVec, VRght and LogScaleRght
         call dcopy(NumNS*NumNS*2, IdMtR(1, 1, 1), 1, URght(1, 1, 1, Iwalk), 1)
         DRghtVec(1:NumNS, 1:2, Iwalk) = 1.0_rp
         call dcopy(NumNS*NumNS*2, IdMtR(1, 1, 1), 1, VRght(1, 1, 1, Iwalk), 1)
         LogScaleRght(1:2, Iwalk) = 0.0_rp
         !!!!!!!!!! For VLeft, DLeftVec, ULeft and LogScaleLeft
         VLeft = IdMtR; DLeftVec = 1.0_rp; ULeft = IdMtR; LogScaleLeft = 0.0_rp
!________________________________________________________________________________________         
!_________________ (3) Sweep from tau=BetaT to tau=0 just to store UDV __________________
!________________________________________________________________________________________
         call SweepBckwdDy(Iwalk, NB, NSW, NTtauEq0)
!________________________________________________________________________________________         
!_________________ (4) Sweep from tau=0 to tau=BetaT just to measure ____________________
!________________________________________________________________________________________  
         call SweepForwdDy(Iwalk, NB, NSW, NTtauEq0)
      enddo
!**************************************************************************************************     
!___________________ 2. Postprocess the measurements data in [Beta, 0] sweep ______________________
!************************************************************************************************** 
      call ProcMeaM2One()
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
!_________________ Counting calling times and time consumed for Beta --> 0 sweep and measure __________________
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
      call system_clock(time2)
      TimeM2One = TimeM2One + TimeIntrvl(time1, time2)
            
   end subroutine SweepM2One
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
   
   
      
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
   subroutine SweepBckwdDy(Iwalk, NB, NSW, NTtauEq0)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  SweepBckwdDy(Iwalk, NB, NSW, NTtauEq0)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to propagate URght from tau=BetaT to tau=0, and store the UDV matrices.
! KEYWORDS: Propagate ULeft from tau=BetaT to tau=0.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Input:  Iwalk    --> Integer index for random walker;
!             NB       --> BIN index;
!             NSW      --> Integer index for sweeps;
!             NTtauEq0 --> NT index for tau==0 point.
!
!     Output: (none)
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________     
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
            use RealPrecsn
            use CoreParamt
            implicit none
!______________________________________________________________________________________________________________     
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
      integer Iwalk, NB, NSW, NTtauEq0
!______________________________________________________________________________________________________________     
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________ 
      integer NTItr, NT
!______________________________________________________________________________________________________________     
!________________________ Main calculations of Propagating URght from tau=0 to tau=Beta _______________________
!______________________________________________________________________________________________________________
!**************************************************************************************************     
!___________________ 0. Sweep from tau==BetaT to tau==0 and store VDU matrices ____________________
!**************************************************************************************************  
      do NTItr = LTrot, 1, -1
!________________________________________________________________________________________         
!_________________ (0) Obtain the correct time slice index integer ______________________
!________________________________________________________________________________________
         NT = mod(NTItr+NTtauEq0-1, LTrot) + 1
!________________________________________________________________________________________         
!_________________ (1) Check and Perform numerical stablization for ULeft _______________
!________________________________________________________________________________________
         if( mod(NTItr, NvStbM2One) == 0 .and. NTItr /= LTrot ) then
            call NmStablizeM2One("bckward", Iwalk, NB, NSW, NTItr)
         end if
!________________________________________________________________________________________         
!_________________ (2) Propagate ULeft = ULeft * \Exp(-\Delta\tau H) ____________________
!________________________________________________________________________________________
         call PropgtURtDynGrF("bckward", Iwalk, NTItr, NT)
      enddo
!**************************************************************************************************     
!___________________ 1. Numerical Stablization for NTItr == 0 point _______________________________
!************************************************************************************************** 
      NTItr = 0
      call NmStablizeM2One("bckward", Iwalk, NB, NSW, NTItr)
      
   end subroutine SweepBckwdDy
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
   


!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
   subroutine SweepForwdDy(Iwalk, NB, NSW, NTtauEq0)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  SweepForwdDy(Iwalk, NB, NSW, NTtauEq0)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to propagate URght from tau=0 to tau=BetaT, and perform measurements.
! KEYWORDS: Propagate URght from tau=0 to tau=BetaT.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Input:  Iwalk    --> Integer index for random walker;
!             NB       --> BIN index;
!             NSW      --> Integer index for sweeps;
!             NTtauEq0 --> NT index for tau==0 point.
!
!     Output: (none)
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________     
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
            use RealPrecsn
      use Observable
            use CoreParamt
            implicit none
!______________________________________________________________________________________________________________     
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
      integer Iwalk, NB, NSW, NTtauEq0
!______________________________________________________________________________________________________________     
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________ 
      integer NTItr, NT, NTInd, SpnInd, I0
      real(rp) ConfgConst
!______________________________________________________________________________________________________________     
!________________________ Main calculations of Propagating URght from tau=0 to tau=BetaT ______________________
!______________________________________________________________________________________________________________
!**************************************************************************************************     
!___________________ 0. Initialization for the sweep and measurements _____________________________
!**************************************************************************************************
!________________________________________________________________________________________               
!_________________ (0) Initialize GrF00, GrFTT, GrFT0 and GrF0T matrices ________________
!_____________________ Initialize the dynamic measurement index _________________________
!________________________________________________________________________________________
      if(IfTAU) then 
         !!!!!!!!!! GrF00, GrFTT, GrFT0 and GrF0T matrices
         call dMat_Copy_QMC(GrnFunct(1, 1, 1, Iwalk), GrF00(1, 1, 1))
         call dMat_Copy_QMC(GrnFunct(1, 1, 1, Iwalk), GrFTT(1, 1, 1))
         call dMat_Copy_QMC(GrnFunct(1, 1, 1, Iwalk), GrFT0(1, 1, 1))
         GrF0T(:, :, :) = - GrnFunct(:, :, :, Iwalk)
         do SpnInd = 1, NmSpn, +1
            do I0 = 1, NumNS, +1
               GrF0T(I0, I0, SpnInd) = 1.0_rp + GrF0T(I0, I0, SpnInd)
            enddo
         enddo
         !!!!!!!!!! The dynamic measurement index
         NTInd = 0
         !!!!!!!!!! The walker related constant
         ConfgConst = WghtProc(Iwalk)
      end if
!**************************************************************************************************     
!___________________ 1. Sweep from tau==0 to tau==BetaT and perform measurements __________________
!**************************************************************************************************
      do NTItr = 0, LTrot, +1
!________________________________________________________________________________________         
!_________________ (0) Obtain the correct time slice index integer ______________________
!________________________________________________________________________________________
         NT = mod(NTItr+NTtauEq0-1, LTrot) + 1
!________________________________________________________________________________________         
!_________________ (1) Propagate GrnFunct, GrFTT, GrFT0 and GrF0T matrices ______________
!________________________________________________________________________________________
         if(NTItr >= 1) call PropgtURtDynGrF("forward", Iwalk, NTItr, NT)
!________________________________________________________________________________________         
!_________________ (2) Perform the Numerical Stablization process _______________________
!________________________________________________________________________________________
         if( (NTItr >= 1) .and. (mod(NTItr, NvStbM2One) == 0 .or. NTItr == LTrot) ) then
            call NmStablizeM2One("forward", Iwalk, NB, NSW, NTItr)
         end if
!________________________________________________________________________________________         
!_________________ (2) Perform static measurements at chosen NT _________________________
!________________________________________________________________________________________
         if( mod(NTItr, NvMeaM2One) == 0 ) then
            call PhyMeaStatM2One(Iwalk, NB, NSW, NTItr)  
            if(Iwalk == IdptWkIndx(NWkBt)) MeaM2One = MeaM2One + 1
         end if
!________________________________________________________________________________________         
!_________________ (3) Perform the Dynamic measurement __________________________________
!________________________________________________________________________________________
         if( IfTAU .and. NTInd <= NumTauPnt ) then
            if( NTItr == TauPntVal(NTInd) ) then
               call ObDynCrFct_SpnDcp(NTInd, ConfgConst, RealSpCrFTauSwp(0, 1, 1))
               NTInd = NTInd + 1
            end if
         end if
      enddo
      
   end subroutine SweepForwdDy
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$



!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
   subroutine PropgtURtDynGrF(ForBckWard, Iwalk, NTItr, NT)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
! PROGRAM:  PropgtURtDynGrF(ForBckWard, Iwalk, NTItr, NT)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to propagate the GrFTT, GrFT0 and GrF0T matrices, for the dynamic measurements.
! KEYWORDS: Propagate Green's functions.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     GrFTT --> B_{NT} * GrFTT * [B_{NT}]^{-1}
!     GrFT0 --> B_{NT} * GrFT0
!     GrF0T -->          GrF0T * [B_{NT}]^{-1}
!
!     Input: ForBckWard --> Character to determine the direction of the sweep;
!            Iwalk      --> Integer index of the random walker;
!            NTItr      --> Integer index for iterations in [LTrot, 1] and [1, LTrot];
!            NT         --> The correct imaginary time slice.
!
!     Outpt: (none).
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
!______________________________________________________________________________________________________________     
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________
      use RealPrecsn
      use TimeRecord
      use QMCTimeRec
      use CoreParamt
      use Observable
            implicit none
!______________________________________________________________________________________________________________     
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
      character(7) ForBckWard
      integer Iwalk, NTItr, NT
!______________________________________________________________________________________________________________     
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer(8) time1, time2
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
!_________________ Counting calling times and time consumed for dynamic propagation ___________________________
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
      TimsB0Pgt = TimsB0Pgt + 1
      call system_clock(time1)
!______________________________________________________________________________________________________________     
!_____________________________ Main calculations of GrF and URght_Dy propagation ______________________________
!______________________________________________________________________________________________________________
!**************************************************************************************************     
!___________________ 0. For ForBckWard == "bckward" case, propagate ULeft matrix __________________
!**************************************************************************************************
      if(ForBckWard == "bckward") then
         !!!!!!!!!! ULeft = ULeft * Exp(-\Delta\tau H_U)
         if( abs(HubbU) > rp_Eps ) then
            call LeftMultExpbU(IsingbU(1, NT, Iwalk), NumNS, ULeft(1, 1, 1))
         end if
         !!!!!!!!!! ULeft = ULeft * Exp(-\Delta\tau H_0)
         call LeftMultExpH0(.false., NumNS, ULeft(1, 1, 1))
      end if
!**************************************************************************************************     
!___________________ 1. For ForBckWard == "forward" case __________________________________________
!______________________ Propagate URght and GrFTT, GrFT0 and GrF0T matrices _______________________
!**************************************************************************************************
      if(ForBckWard == "forward") then
!________________________________________________________________________________________         
!_________________ (0) Propagate the URght matrix for NumStab ___________________________
!________________________________________________________________________________________   
         !!!!!!!!!! URght = Exp(-\Delta\tau H_0) * URght
         call RghtMultExpH0(.false., URght(1, 1, 1, Iwalk), NumNS)
         !!!!!!!!!! URght = Exp(-\Delta\tau H_U) * URght
         if( abs(HubbU) > rp_Eps ) then
            call RghtMultExpbU(IsingbU(1, NT, Iwalk), URght(1, 1, 1, Iwalk), NumNS)
         end if
!________________________________________________________________________________________         
!_________________ (1) Propagate the GrnFunct matrix for measurement ____________________
!________________________________________________________________________________________  
         !!!!!!!!!! GrnFunct = Exp(-Dltau*H_0) * GrnFunct * [Exp(-Dltau*H_0)]^{-1}
         call RghtMultExpH0   (.false., GrnFunct(1, 1, 1, Iwalk), NumNS)
         call LeftMultExpH0Inv(.false., NumNS, GrnFunct(1, 1, 1, Iwalk))
         !!!!!!!!!! GrnFunct = Exp(-Dltau*H_U) * GrnFunct * [Exp(-Dltau*H_U)]^{-1}
         if( abs(HubbU) > rp_Eps ) then
            call RghtMultExpbU   (IsingbU(1, NT, Iwalk), GrnFunct(1, 1, 1, Iwalk), NumNS)
            call LeftMultExpbUInv(IsingbU(1, NT, Iwalk), NumNS, GrnFunct(1, 1, 1, Iwalk)) 
         end if
!________________________________________________________________________________________         
!_________________ (2) Propagate GrFTT, GrFT0 and GrF0T matrices for dynamics ___________
!________________________________________________________________________________________  
         if( (IfTAU) .and. (NTItr <= NmTDM) ) then
            !!!!!!!!!! Copy GrnFunct to GrFTT
            call dMat_Copy_QMC(GrnFunct(1, 1, 1, Iwalk), GrFTT(1, 1, 1))
            !!!!!!!!!! GrFT0 --> B_{NT} * GrFT0
            call RghtMultExpH0(.false., GrFT0(1, 1, 1), NumNS)
            if( abs(HubbU) > rp_Eps ) then
               call RghtMultExpbU(IsingbU(1, NT, Iwalk), GrFT0(1, 1, 1), NumNS)
            end if
            GrFT0 = GrFT0 * exp(-Dltau*ChemP)
            !!!!!!!!!! GrF0T --> GrF0T * [B_{NT}]^{-1}
            call LeftMultExpH0Inv(.false., NumNS, GrF0T(1, 1, 1)) 
            if( abs(HubbU) > rp_Eps ) then
               call LeftMultExpbUInv(IsingbU(1, NT, Iwalk), NumNS, GrF0T(1, 1, 1))  
            end if
            GrF0T = GrF0T * exp(+Dltau*ChemP)
         end if
      end if
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
!_________________ Counting calling times and time consumed for dynamic propagation ___________________________
!%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&  
      call system_clock(time2)
      TimeB0Pgt = TimeB0Pgt + TimeIntrvl(time1, time2)
      
   end subroutine PropgtURtDynGrF
!________________________________________________________________________________________________________________________  
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$