!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! PROGRAM: Several subroutines used to calculate the matrix inverse for both complex and real matrices, 
!               by applying the ULR decomposition method.
! COMMENT: Calculating the matrix inverse. 
! AUTHOR:  Yuan-Yao He
! DATE:    2020-02-27
! PURPOSE: Different subroutines are introduced as following:
!             
!   MatInversZ_NoDet  --> Subroutine to calculate matrix inverse for complex matrix, without  determinant;
!   MatInversZ_Det    --> Subroutine to calculate matrix inverse for complex matrix, with     determinant;
!   MatInversZ_LogDet --> Subroutine to calculate matrix inverse for complex matrix, with log determinant;
!
!   MatInversR_NoDet  --> Subroutine to calculate matrix inverse for real    matrix, without  determinant;
!   MatInversR_Det    --> Subroutine to calculate matrix inverse for real    matrix, with     determinant;
!   MatInversR_LogDet --> Subroutine to calculate matrix inverse for real    matrix, with log determinant;
!             
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


   
   
!########################################################################################################################
!########################################################################################################################
!########################################################################################################################
!################################################# For Complex Version ##################################################
!################################################# For Complex Version ##################################################
!################################################# For Complex Version ##################################################
!########################################################################################################################
!########################################################################################################################
!########################################################################################################################
   
 

!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________
	subroutine MatInversZ_NoDet(NDim, zMat, LDA)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! PROGRAM:  MatInversZ_NoDet(NDim, zMat, LDA)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to calculate the matrix inverse for complex square matrix, 
!                 and the input A is overwrite by Inv(A).
! KEYWORDS: Calculate Matrix inverse, complex version.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Calculate Matrix inverse, complex version. 
!
!     Input: NDim --> Dimension of input A matrix;
!            zMat --> Input complex square matrix;
!            LDA  --> Leading dimension of zMat matrix;
!
!     Outpt: zMat --> Result output complex inv matrix of A matrix.
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 			
!______________________________________________________________________________________________________________	  
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
      implicit none
!______________________________________________________________________________________________________________	  
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
		integer NDim                              ! Dimension of A square matrix
      integer LDA
		complex(kind=kind(0.d0)) zMat(LDA, *)     ! The input A matrix
!______________________________________________________________________________________________________________	  
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer IError
      
      integer, allocatable :: ipiv(:)
      complex(kind=kind(0.d0)), allocatable :: work(:)
!______________________________________________________________________________________________________________	  
!__________________________________ Allocate Array and Initializations ________________________________________
!______________________________________________________________________________________________________________
		allocate(ipiv(NDim), stat=ierror)
		allocate(work(NDim), stat=ierror)
		if ( ierror /= 0 ) then
         write(*, "('MatInversZ_NoDet: can not allocate enough memory! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!_______________________________ Main calculations of Matrix Inverse __________________________________________
!______________________________________________________________________________________________________________
!________________________________________________________________________________________________	  
!____________________________ 1. A = P*L*U decomposition for zMat matrix ________________________
!________________________________________________________________________________________________
		call ZGETRF(NDim, NDim, zMat, LDA, ipiv, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversZ_NoDet: error in lapack subroutine ZGETRF! ierror = ', I4)") ierror
         stop
      end if
!________________________________________________________________________________________________	  
!____________________________ 2. Use inv(A) * P * L = inv(U) to slove inv(A) ____________________
!________________________________________________________________________________________________      
      call ZGETRI(NDim, zMat, LDA, ipiv, work, NDim, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversZ_NoDet: error in lapack subroutine ZGETRI! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!___________________________________________ Deallocate the arrays ____________________________________________
!______________________________________________________________________________________________________________
		if(allocated(ipiv)) deallocate(ipiv)
		if(allocated(work)) deallocate(work)
		
   end subroutine MatInversZ_NoDet
!________________________________________________________________________________________________________________________
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
   

   

!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________ 
	subroutine MatInversZ_Det(NDim, zMat, LDA, zDet)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
! PROGRAM:  MatInversZ_Det(NDim, zMat, LDA, zDet)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to calculate the matrix inverse for complex square matrix 
!                  and its determinant, and the input A is overwrite by Inv(A).
! KEYWORDS: Calculate Matrix inverse, complex version.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Calculate Matrix inverse, complex version. 
!
!     Input: NDim --> Dimension of input zMat matrix;
!            zMat --> Input complex square matrix;
!            LDA  --> Leading dimension of zMat matrix.
!
!     Outpt: zMat --> Result output complex inv matrix of A matrix.
!            zDet --> Complex determinant.     
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 			
!______________________________________________________________________________________________________________	  
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________ 
      implicit none
!______________________________________________________________________________________________________________	  
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
		integer NDim                                  ! Dimension of zMat square matrix
      integer LDA
      complex(kind=kind(0.d0)) zDet                 ! Determinant of zMat matrix
		complex(kind=kind(0.d0)) zMat(LDA, *)         ! The input zMat matrix
!______________________________________________________________________________________________________________	  
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer IError
      integer I1
      
      integer, allocatable :: ipiv(:)
      complex(kind=kind(0.d0)), allocatable :: work(:)
!______________________________________________________________________________________________________________	  
!__________________________________ Allocate Array and Initializations ________________________________________
!______________________________________________________________________________________________________________
		allocate(ipiv(NDim), stat=ierror)
		allocate(work(NDim), stat=ierror)
		if ( ierror /= 0 ) then
         write(*, "('MatInversZ_Det: can not allocate enough memory! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!_______________________________ Main calculations of Matrix Inverse __________________________________________
!______________________________________________________________________________________________________________
!________________________________________________________________________________________________	  
!____________________________ 1. A = P*L*U decomposition for zMat matrix ________________________
!________________________________________________________________________________________________
		call ZGETRF(NDim, NDim, zMat, LDA, ipiv, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversZ_Det: error in lapack subroutine ZGETRF! ierror = ', I4)") ierror
         stop
      end if
!________________________________________________________________________________________________	  
!____________________________ 2. Get the complex determinant of zMat matrix _____________________
!________________________________________________________________________________________________          
      zDet = dcmplx(1.0d0, 0.0d0)
      do I1 = 1, ndim
         if( ipiv(I1) == I1 ) then
            zDet = zDet * ( +zMat(I1, I1) )
         else
            zDet = zDet * ( -zMat(I1, I1) )
         end if  
     enddo
!________________________________________________________________________________________________	  
!____________________________ 2. Use inv(A) * P * L = inv(U) to slove inv(A) ____________________
!________________________________________________________________________________________________         
      call ZGETRI(NDim, zMat, LDA, ipiv, work, NDim, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversZ_Det: error in lapack subroutine ZGETRI! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!___________________________________________ Deallocate the arrays ____________________________________________
!______________________________________________________________________________________________________________
		if(allocated(ipiv)) deallocate(ipiv)
		if(allocated(work)) deallocate(work)
		
   end subroutine MatInversZ_Det
!________________________________________________________________________________________________________________________ 
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
   

   
   
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________ 
	subroutine MatInversZ_LogDet(NDim, zMat, LDA, LogzDet)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
! PROGRAM:  MatInversZ_LogDet(NDim, zMat, LDA, LogzDet)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to calculate the matrix inverse for complex square matrix 
!                  and its determinant, and the input A is overwrite by Inv(A).
! KEYWORDS: Calculate Matrix inverse, complex version.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Calculate Matrix inverse, complex version. 
!
!     Input: NDim --> Dimension of input zMat matrix;
!            zMat --> Input complex square matrix;
!            LDA  --> Leading dimension of zMat matrix.
!
!     Outpt: zMat --> Result output complex inv matrix of A matrix.
!            LogzDet --> Complex log(determinant).     
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 			
!______________________________________________________________________________________________________________	  
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________  
      implicit none
!______________________________________________________________________________________________________________	  
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
		integer NDim                                  ! Dimension of zMat square matrix
      integer LDA
      complex(kind=kind(0.d0)) LogzDet              ! Determinant of zMat matrix
		complex(kind=kind(0.d0)) zMat(LDA, *)         ! The input zMat matrix
!______________________________________________________________________________________________________________	  
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer IError
      integer I1
      integer Itp0
      
      real(kind=kind(0.d0)) rp_pi
      real(kind=kind(0.d0)) ReLogzDet
      real(kind=kind(0.d0)) ImLogzDet
      
      integer, allocatable :: ipiv(:)
      complex(kind=kind(0.d0)), allocatable :: work(:)
!______________________________________________________________________________________________________________	  
!__________________________________ Allocate Array and Initializations ________________________________________
!______________________________________________________________________________________________________________
		allocate(ipiv(NDim), stat=ierror)
		allocate(work(NDim), stat=ierror)
		if ( ierror /= 0 ) then
         write(*, "('MatInversZ_LogDet: can not allocate enough memory! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!_______________________________ Main calculations of Matrix Inverse __________________________________________
!______________________________________________________________________________________________________________
!________________________________________________________________________________________________	  
!____________________________ 1. A = P*L*U decomposition for zMat matrix ________________________
!________________________________________________________________________________________________
		call ZGETRF(NDim, NDim, zMat, LDA, ipiv, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversZ_LogDet: error in lapack subroutine ZGETRF! ierror = ', I4)") ierror
         stop
      end if
!________________________________________________________________________________________________	  
!____________________________ 2. Get the complex determinant of zMat matrix _____________________
!________________________________________________________________________________________________          
      LogzDet = dcmplx(0.0d0, 0.0d0)
      do I1 = 1, ndim
         if( ipiv(I1) == I1 ) then
            LogzDet = LogzDet + log(+zMat(I1, I1))
         else
            LogzDet = LogzDet + log(-zMat(I1, I1))
         end if  
      enddo
      
      rp_pi = dacos( -1.0d0 )
      ReLogzDet = dreal(LogzDet)
      ImLogzDet = dimag(LogzDet)
      Itp0 = nint(ImLogzDet/2.0d0/rp_pi)
      ImLogzDet = ImLogzDet - 2.0d0*rp_pi*dble(Itp0)
      LogzDet = dcmplx(ReLogzDet, ImLogzDet)
!________________________________________________________________________________________________	  
!____________________________ 2. Use inv(A) * P * L = inv(U) to slove inv(A) ____________________
!________________________________________________________________________________________________           
      call ZGETRI(NDim, zMat, LDA, ipiv, work, NDim, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversZ_LogDet: error in lapack subroutine ZGETRI! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!___________________________________________ Deallocate the arrays ____________________________________________
!______________________________________________________________________________________________________________
		if(allocated(ipiv)) deallocate(ipiv)
		if(allocated(work)) deallocate(work)
		
   end subroutine MatInversZ_LogDet
!________________________________________________________________________________________________________________________ 
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


   
   
!########################################################################################################################
!########################################################################################################################
!########################################################################################################################
!################################################# For Real Version #####################################################
!################################################# For Real Version #####################################################
!################################################# For Real Version #####################################################
!########################################################################################################################
!########################################################################################################################
!########################################################################################################################
   
   
   
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________ 
	subroutine MatInversR_NoDet(NDim, dMat, LDA)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
! PROGRAM:  MatInversR_NoDet(NDim, dMat, LDA)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to calculate the matrix inverse for real square matrix, 
!                    and the input A is overwrite by Inv(A).
! KEYWORDS: Calculate Matrix inverse, real version.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Calculate Matrix inverse, real version. 
!
!     Input: NDim --> Dimension of input A matrix;
!            dMat --> Input real square matrix;
!            LDA  --> Leading dimension of dMat matrix.
!
!     Outpt: dMat --> Result output real inv matrix of A matrix.
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 			
!______________________________________________________________________________________________________________	  
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________  
      implicit none
!______________________________________________________________________________________________________________	  
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
		integer NDim                                  ! Dimension of A square matrix
      integer LDA
		real(kind=kind(0.d0)) dMat(LDA, *)        ! The input A matrix
!______________________________________________________________________________________________________________	  
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer IError
      
      integer, allocatable :: ipiv(:)
      real(kind=kind(0.d0)), allocatable :: work(:)
!______________________________________________________________________________________________________________	  
!__________________________________ Allocate Array and Initializations ________________________________________
!______________________________________________________________________________________________________________
		allocate(ipiv(NDim), stat=ierror)
		allocate(work(NDim), stat=ierror)
		if ( ierror /= 0 ) then
         write(*, "('MatInversR_NoDet: can not allocate enough memory! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!_______________________________ Main calculations of Matrix Inverse __________________________________________
!______________________________________________________________________________________________________________
!________________________________________________________________________________________________	  
!____________________________ 1. A = P*L*U decomposition for dMat matrix ________________________
!________________________________________________________________________________________________
		call DGETRF(NDim, NDim, dMat, LDA, ipiv, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversR_NoDet: error in lapack subroutine DGETRF! ierror = ', I4)") ierror
         stop
      end if
!________________________________________________________________________________________________	  
!____________________________ 2. Use inv(A) * P * L = inv(U) to slove inv(A) ____________________
!________________________________________________________________________________________________      
      call DGETRI(NDim, dMat, LDA, ipiv, work, NDim, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversR_NoDet: error in lapack subroutine DGETRI! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!___________________________________________ Deallocate the arrays ____________________________________________
!______________________________________________________________________________________________________________
		if(allocated(ipiv)) deallocate(ipiv)
		if(allocated(work)) deallocate(work)
		
   end subroutine MatInversR_NoDet
!________________________________________________________________________________________________________________________ 
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
   

   

!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________ 
	subroutine MatInversR_Det(NDim, dMat, LDA, dDet)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
! PROGRAM:  MatInversR_Det(NDim, dMat, LDA, dDet)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to calculate the matrix inverse for real square matrix 
!                  and its determinant, and the input A is overwrite by Inv(A).
! KEYWORDS: Calculate Matrix inverse, real version.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Calculate Matrix inverse, real version. 
!
!     Input: NDim --> Dimension of input dMat matrix;
!            dMat --> Input real square matrix;
!            LDA  --> Leading dimension of dMat matrix.
!
!     Outpt: dMat --> Result output real inv matrix of A matrix.
!            dDet --> real determinant.     
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 			
!______________________________________________________________________________________________________________	  
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________  
      implicit none
!______________________________________________________________________________________________________________	  
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
		integer NDim                              ! Dimension of dMat square matrix
      integer LDA
      real(kind=kind(0.d0)) dDet                ! Determinant of dMat matrix
		real(kind=kind(0.d0)) dMat(LDA, *)        ! The input dMat matrix
!______________________________________________________________________________________________________________	  
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer IError
      
      integer I1
      
      integer, allocatable :: ipiv(:)
      real(kind=kind(0.d0)), allocatable :: work(:)
!______________________________________________________________________________________________________________	  
!__________________________________ Allocate Array and Initializations ________________________________________
!______________________________________________________________________________________________________________
		allocate(ipiv(NDim), stat=ierror)
		allocate(work(NDim), stat=ierror)
		if ( ierror /= 0 ) then
         write(*, "('MatInversR_Det: can not allocate enough memory! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!_______________________________ Main calculations of Matrix Inverse __________________________________________
!______________________________________________________________________________________________________________
!________________________________________________________________________________________________	  
!____________________________ 1. A = P*L*U decomposition for dMat matrix ________________________
!________________________________________________________________________________________________
		call DGETRF(NDim, NDim, dMat, LDA, ipiv, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversR_Det: error in lapack subroutine DGETRF! ierror = ', I4)") ierror
         stop
      end if
!________________________________________________________________________________________________	  
!____________________________ 2. Get the real determinant of dMat matrix ________________________
!________________________________________________________________________________________________          
      dDet = dcmplx(1.0d0, 0.0d0)
      do I1 = 1, ndim
         if( ipiv(I1) == I1 ) then
            dDet = dDet * ( +dMat(I1, I1) )
         else
            dDet = dDet * ( -dMat(I1, I1) )
         end if  
     enddo
!________________________________________________________________________________________________	  
!____________________________ 2. Use inv(A) * P * L = inv(U) to slove inv(A) ____________________
!________________________________________________________________________________________________         
      call DGETRI(NDim, dMat, LDA, ipiv, work, NDim, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversR_Det: error in lapack subroutine DGETRI! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!___________________________________________ Deallocate the arrays ____________________________________________
!______________________________________________________________________________________________________________
		if(allocated(ipiv)) deallocate(ipiv)
		if(allocated(work)) deallocate(work)
		
   end subroutine MatInversR_Det
!________________________________________________________________________________________________________________________ 
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
   

   
   
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!____________________________________ Begin subroutine __________________________________________________________________
!________________________________________________________________________________________________________________________ 
	subroutine MatInversR_LogDet(NDim, dMat, LDA, LogzDet)
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
! PROGRAM:  MatInversR_LogDet(NDim, dMat, LDA, LogzDet)
! TYPE:     subroutine
! PURPOSE:  This Subroutine is used to calculate the matrix inverse for real square matrix 
!                  and its determinant, and the input A is overwrite by Inv(A).
! KEYWORDS: Calculate Matrix inverse, real version.
! AUTHOR:   Yuan-Yao He
! TIME:     2020-02-27
! DESCRIPTION:
!
!     Calculate Matrix inverse, real version. 
!     The matrix must have real determinant, but we want to incorporate the -1 sign, so we use complex LogzDet here.
!
!     Input: NDim --> Dimension of input dMat matrix;
!            dMat --> Input real square matrix;
!            LDA  --> Leading dimension of dMat matrix.
!
!     Outpt: dMat --> Result output real inv matrix of A matrix.
!            LogzDet --> Complex log(determinant).     
!
! END PROGRAM
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 			
!______________________________________________________________________________________________________________	  
!_________________________________________ Modules used in this subroutine ____________________________________
!______________________________________________________________________________________________________________  
      implicit none
!______________________________________________________________________________________________________________	  
!_________________________________________ All Input and Output Quantities ____________________________________
!______________________________________________________________________________________________________________
		integer NDim                              ! Dimension of dMat square matrix
      integer LDA
      complex(kind=kind(0.d0)) LogzDet          ! Determinant of dMat matrix
		real(kind=kind(0.d0)) dMat(LDA, *)        ! The input dMat matrix
!______________________________________________________________________________________________________________	  
!______________________________ Temperory Quantities used in the calculations _________________________________
!______________________________________________________________________________________________________________
      integer IError
      
      integer I1
      integer Itp0
      
      real(kind=kind(0.d0)) rp_pi
      real(kind=kind(0.d0)) ReLogzDet
      real(kind=kind(0.d0)) ImLogzDet
      
      integer, allocatable :: ipiv(:)
      real(kind=kind(0.d0)), allocatable :: work(:)
!______________________________________________________________________________________________________________	  
!__________________________________ Allocate Array and Initializations ________________________________________
!______________________________________________________________________________________________________________
		allocate(ipiv(NDim), stat=ierror)
		allocate(work(NDim), stat=ierror)
		if ( ierror /= 0 ) then
         write(*, "('MatInversR_LogDet: can not allocate enough memory! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!_______________________________ Main calculations of Matrix Inverse __________________________________________
!______________________________________________________________________________________________________________
!________________________________________________________________________________________________	  
!____________________________ 1. A = P*L*U decomposition for dMat matrix ________________________
!________________________________________________________________________________________________
		call DGETRF(NDim, NDim, dMat, LDA, ipiv, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversR_LogDet: error in lapack subroutine DGETRF! ierror = ', I4)") ierror
         stop
      end if
!________________________________________________________________________________________________	  
!____________________________ 2. Get the complex determinant of dMat matrix _____________________
!________________________________________________________________________________________________          
      LogzDet = dcmplx(0.0d0, 0.0d0)
      do I1 = 1, ndim
         if( ipiv(I1) == I1 ) then
            LogzDet = LogzDet + log(dcmplx(+dMat(I1, I1), 0.d0))
         else
            LogzDet = LogzDet + log(dcmplx(-dMat(I1, I1), 0.d0))
         end if  
      enddo

      rp_pi = dacos( -1.0d0 )
      ReLogzDet = dreal(LogzDet)
      ImLogzDet = dimag(LogzDet)
      Itp0 = nint(ImLogzDet/2.0d0/rp_pi)
      ImLogzDet = ImLogzDet - 2.0d0*rp_pi*dble(Itp0)
      LogzDet = dcmplx(ReLogzDet, ImLogzDet)
!________________________________________________________________________________________________	  
!____________________________ 2. Use inv(A) * P * L = inv(U) to slove inv(A) ____________________
!________________________________________________________________________________________________           
      call DGETRI(NDim, dMat, LDA, ipiv, work, NDim, Ierror)
      if ( ierror /= 0 ) then
         write(*, "('MatInversR_LogDet: error in lapack subroutine DGETRI! ierror = ', I4)") ierror
         stop
      end if
!______________________________________________________________________________________________________________	  
!___________________________________________ Deallocate the arrays ____________________________________________
!______________________________________________________________________________________________________________
		if(allocated(ipiv)) deallocate(ipiv)
		if(allocated(work)) deallocate(work)
		
   end subroutine MatInversR_LogDet
!________________________________________________________________________________________________________________________ 
!____________________________________ End subroutine ____________________________________________________________________
!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
